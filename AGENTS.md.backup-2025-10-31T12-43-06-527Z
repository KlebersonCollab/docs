<!-- RULEBOOK:START -->
# Project Rules

Generated by @hivellm/rulebook
Generated at: 2025-10-30T16:35:28.603Z

## Documentation Standards

Documentation should be well-organized in the `/docs` directory.

## Testing Requirements

**CRITICAL**: All features must have comprehensive tests.

- **Minimum Coverage**: 95%
- **Test Location**: `/tests` directory in project root
- **Test Execution**: 100% of tests MUST pass before moving to next task
- **Test First**: Write tests based on specifications before implementation

## Feature Development Workflow

**CRITICAL**: Follow this workflow for all feature development.

1. **Check Specifications First**:
   - Read `/docs/specs/` for feature specifications
   - Review `/docs/ARCHITECTURE.md` for system design
   - Check `/docs/ROADMAP.md` for implementation timeline
   - Review `/docs/DAG.md` for component dependencies

2. **Implement with Tests**:
   - Write tests in `/tests` directory first
   - Implement feature following specifications
   - Ensure tests pass and meet coverage threshold

3. **Quality Checks**:
   - Run code formatter
   - Run linter (must pass with no warnings)
   - Run all tests (must be 100% passing)
   - Verify coverage meets threshold

4. **Update Documentation**:
   - Update `/docs/ROADMAP.md` progress
   - Update feature specs if implementation differs
   - Document any deviations with justification

## Rules Configuration

Rules can be selectively disabled using `.rulesignore` file in project root.

Example `.rulesignore`:
```
# Ignore coverage requirement
coverage-threshold
# Ignore specific language rules
rust/edition-2024
# Ignore all TypeScript rules
typescript/*
```

<!-- RULEBOOK:END -->


<!-- OPENSPEC:START -->
# OpenSpec Instructions

**CRITICAL**: Use OpenSpec for managing change proposals, specifications, and feature planning.

OpenSpec provides a structured workflow for proposing, reviewing, and implementing changes to the project. Always check for existing specs before implementing features.

## When to Use OpenSpec

Use OpenSpec when the request:

- Mentions planning or proposals (words like "proposal", "spec", "change", "plan")
- Introduces new capabilities or features
- Involves breaking changes or API modifications
- Requires architecture shifts or major refactoring
- Includes significant performance or security work
- Sounds ambiguous and needs clarification before coding

## OpenSpec Workflow

### 1. Check Existing Specs

Before implementing any feature:

```
1. Check /openspec directory for existing proposals
2. Review @/openspec/AGENTS.md for conventions
3. Search for related specs or RFCs
4. Read relevant specifications thoroughly
```

### 2. Create New Proposal

For new features or significant changes:

```
1. Use OpenSpec format for proposal
2. Include rationale, design, alternatives
3. Document breaking changes
4. Specify acceptance criteria
5. Request review from maintainers
```

### 3. Implementation

Follow the approved spec:

```
1. Implement exactly as specified
2. Document any deviations with justification
3. Update spec if design changes during implementation
4. Reference spec in commit messages
5. Mark spec as implemented when complete
```

### 4. Review and Iterate

Continuous improvement:

```
1. Collect feedback during implementation
2. Update spec with learnings
3. Document issues and resolutions
4. Archive completed specs appropriately
```

## Spec Format

Follow the OpenSpec conventions:

```markdown
# [Spec Title]

## Status
[Draft | Under Review | Approved | Implemented | Rejected]

## Summary
Brief description of the proposal.

## Motivation
Why is this change needed?

## Detailed Design
How will this be implemented?

## Alternatives Considered
What other approaches were considered?

## Breaking Changes
Any breaking changes and migration path.

## Acceptance Criteria
How to verify the implementation is complete.
```

## Best Practices

1. **Read Before Implementing**: Always check `/openspec/AGENTS.md` first
2. **Follow Conventions**: Use the specified format and structure
3. **Be Thorough**: Include all relevant details and considerations
4. **Update Actively**: Keep specs current during implementation
5. **Reference Specs**: Link specs in commits, PRs, and documentation

## Integration with Development Workflow

### Before Starting Work

```
1. Check: Does a spec exist for this feature?
2. If yes: Read and understand the complete specification
3. If no: Should this have a spec? (significant features should)
4. If needed: Create proposal and get approval before implementing
```

### During Implementation

```
1. Follow the spec exactly
2. Document deviations immediately
3. Update spec if design changes
4. Add implementation notes to spec
```

### After Completion

```
1. Mark spec as implemented
2. Update with actual implementation details
3. Document any differences from original design
4. Archive or move to appropriate location
```

## Common Patterns

### Pattern 1: New Feature

```
1. Create proposal in /openspec/proposals/
2. Get feedback and approval
3. Implement according to spec
4. Update /docs/specs/ with final design
5. Mark proposal as implemented
```

### Pattern 2: Breaking Change

```
1. Create RFC (Request for Comments)
2. Document migration path
3. Get community/team review
4. Implement with migration guide
5. Update CHANGELOG.md and version docs
```

### Pattern 3: Architecture Change

```
1. Create architecture proposal
2. Include diagrams and detailed design
3. Review with architecture team
4. Implement in phases if needed
5. Update /docs/ARCHITECTURE.md
```

## File Organization

```
/openspec/
├── AGENTS.md          # OpenSpec conventions
├── proposals/         # Active proposals
├── rfcs/              # Requests for comments
├── implemented/       # Completed specs
└── rejected/          # Declined proposals
```

<!-- OPENSPEC:END -->




<!-- RUST:START -->
# Rust Project Rules

## Rust Edition and Toolchain

**CRITICAL**: Always use Rust Edition 2024 with nightly toolchain.

- **Edition**: 2024
- **Toolchain**: nightly 1.85+
- **Update**: Run `rustup update nightly` regularly

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code (nightly required for Edition 2024)
cargo +nightly fmt --all

# 2. Check for warnings (MUST pass with no warnings)
cargo clippy --workspace -- -D warnings

# 3. Check all targets and features
cargo clippy --workspace --all-targets --all-features -- -D warnings

# 4. Run all tests (MUST pass 100%)
cargo test --workspace --tests --verbose

# 5. Check coverage (MUST meet threshold)
cargo llvm-cov --all --ignore-filename-regex 'examples'
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Formatting

- Use `rustfmt` with nightly toolchain
- Configuration in `rustfmt.toml` or `.rustfmt.toml`
- Always format before committing: `cargo +nightly fmt --all`
- CI must check formatting: `cargo +nightly fmt --all -- --check`

### Linting

- Use `clippy` with `-D warnings` (warnings as errors)
- Fix all clippy warnings before committing
- Acceptable exceptions must be documented with `#[allow(clippy::...)]` and justification
- CI must enforce clippy: `cargo clippy --workspace -- -D warnings`

### Testing

- **Location**: Tests in `/tests` directory for integration tests
- **Unit Tests**: In same file as implementation with `#[cfg(test)]`
- **Coverage**: Must meet project threshold (default 95%)
- **Tools**: Use `cargo-nextest` for faster test execution
- **Async**: Use `tokio::test` for async tests with Tokio runtime

Example test structure:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_feature() {
        // Test implementation
    }

    #[tokio::test]
    async fn test_async_feature() {
        // Async test implementation
    }
}
```

## Async Programming

**CRITICAL**: Follow Tokio best practices for async code.

- **Runtime**: Use Tokio for async runtime
- **Blocking**: Never block in async context - use `spawn_blocking` for CPU-intensive tasks
- **Channels**: Use `tokio::sync::mpsc` or `tokio::sync::broadcast` for async communication
- **Timeouts**: Always set timeouts for network operations: `tokio::time::timeout`

Example:
```rust
use tokio::time::{timeout, Duration};

async fn fetch_data() -> Result<Data, Error> {
    timeout(Duration::from_secs(30), async {
        // Network operation
    }).await?
}
```

## Dependency Management

**CRITICAL**: Always verify latest versions before adding dependencies.

### Before Adding Any Dependency

1. **Check Context7 for latest version**:
   - Use MCP Context7 tool if available
   - Search for the crate documentation
   - Verify the latest stable version
   - Review breaking changes and migration guides

2. **Example Workflow**:
   ```
   Adding tokio → Check crates.io and docs.rs
   Adding serde → Verify latest version with security updates
   Adding axum → Check for breaking changes in latest version
   ```

3. **Document Version Choice**:
   - Note why specific version chosen in `Cargo.toml` comments
   - Document any compatibility constraints
   - Update CHANGELOG.md with new dependencies

### Dependency Guidelines

- ✅ Use latest stable versions
- ✅ Check for security advisories: `cargo audit`
- ✅ Prefer well-maintained crates (active development, good documentation)
- ✅ Minimize dependency count
- ✅ Use workspace dependencies for monorepos
- ❌ Don't use outdated versions without justification
- ❌ Don't add dependencies without checking latest version

## Codespell Configuration

**CRITICAL**: Use codespell to catch typos in code and documentation.

Install: `pip install 'codespell[toml]'`

Configuration in `pyproject.toml`:
```toml
[tool.codespell]
skip = "*.lock,*.json,target,node_modules,.git"
ignore-words-list = "crate,ser,deser"
```

Or run with flags:
```bash
codespell \
  --skip="*.lock,*.json,target,node_modules,.git" \
  --ignore-words-list="crate,ser,deser"
```

## Error Handling

- Use `Result<T, E>` for recoverable errors
- Use `thiserror` for custom error types
- Use `anyhow` for application-level error handling
- Document error conditions in function docs
- Never use `unwrap()` or `expect()` in production code without justification

Example:
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
}

pub fn process_data(input: &str) -> Result<Data, MyError> {
    // Implementation
}
```

## Documentation

- **Public APIs**: Must have doc comments (`///`)
- **Examples**: Include examples in doc comments
- **Modules**: Document module purpose with `//!`
- **Unsafe**: Always document safety requirements for `unsafe` code
- **Run doctests**: `cargo test --doc`

Example:
```rust
/// Processes the input data and returns a result.
///
/// # Arguments
///
/// * `input` - The input string to process
///
/// # Examples
///
/// ```
/// use mylib::process;
/// let result = process("hello");
/// assert_eq!(result, "HELLO");
/// ```
///
/// # Errors
///
/// Returns `MyError::InvalidInput` if input is empty.
pub fn process(input: &str) -> Result<String, MyError> {
    // Implementation
}
```

## Project Structure

```
project/
├── Cargo.toml          # Package manifest
├── Cargo.lock          # Dependency lock file (commit this)
├── README.md           # Project overview (allowed in root)
├── CHANGELOG.md        # Version history (allowed in root)
├── AGENTS.md          # AI assistant rules (allowed in root)
├── LICENSE            # Project license (allowed in root)
├── CONTRIBUTING.md    # Contribution guidelines (allowed in root)
├── CODE_OF_CONDUCT.md # Code of conduct (allowed in root)
├── SECURITY.md        # Security policy (allowed in root)
├── src/
│   ├── lib.rs          # Library root (for libraries)
│   ├── main.rs         # Binary root (for applications)
│   └── ...
├── tests/              # Integration tests
├── examples/           # Example code
├── benches/            # Benchmarks
└── docs/               # Project documentation
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`rust-test.yml`):
   - Test on ubuntu-latest, windows-latest, macos-latest
   - Use `cargo-nextest` for fast test execution
   - Upload test results

2. **Linting** (`rust-lint.yml`):
   - Format check: `cargo +nightly fmt --all -- --check`
   - Clippy: `cargo clippy --workspace -- -D warnings`
   - All targets: `cargo clippy --workspace --all-targets -- -D warnings`

3. **Codespell** (`codespell.yml`):
   - Check for typos in code and documentation
   - Fail on errors

## Crate Publication

### Publishing to crates.io

**Prerequisites:**
1. Create account at https://crates.io
2. Generate API token: `cargo login`
3. Add `CARGO_TOKEN` to GitHub repository secrets

**Cargo.toml Configuration:**

```toml
[package]
name = "your-crate-name"
version = "1.0.0"
edition = "2024"
authors = ["Your Name <your.email@example.com>"]
license = "MIT OR Apache-2.0"
description = "A short description of your crate"
documentation = "https://docs.rs/your-crate-name"
homepage = "https://github.com/your-org/your-crate-name"
repository = "https://github.com/your-org/your-crate-name"
readme = "README.md"
keywords = ["your", "keywords", "here"]
categories = ["category"]
exclude = [
    ".github/",
    "tests/",
    "benches/",
    "examples/",
    "*.sh",
]

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]
```

**Publishing Workflow:**

1. Update version in Cargo.toml
2. Update CHANGELOG.md
3. Run quality checks:
   ```bash
   cargo fmt --all
   cargo clippy --workspace --all-targets -- -D warnings
   cargo test --all-features
   cargo doc --no-deps --all-features
   ```
4. Create git tag: `git tag v1.0.0 && git push --tags`
5. GitHub Actions automatically publishes to crates.io
6. Or manual publish: `cargo publish`

**Publishing Checklist:**

- ✅ All tests passing (`cargo test --all-features`)
- ✅ No clippy warnings (`cargo clippy -- -D warnings`)
- ✅ Code formatted (`cargo fmt --all -- --check`)
- ✅ Documentation builds (`cargo doc --no-deps`)
- ✅ Version updated in Cargo.toml
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ LICENSE file present
- ✅ Package size < 10MB (check with `cargo package --list`)
- ✅ Verify with `cargo publish --dry-run`

**Semantic Versioning:**

Follow [SemVer](https://semver.org/) strictly:
- **MAJOR**: Breaking API changes
- **MINOR**: New features (backwards compatible)
- **PATCH**: Bug fixes (backwards compatible)

**Documentation:**

- Use `///` for public API documentation
- Include examples in doc comments
- Use `#![deny(missing_docs)]` for libraries
- Test documentation examples with `cargo test --doc`

```rust
/// Processes the input data and returns a result.
///
/// # Arguments
///
/// * `input` - The input string to process
///
/// # Examples
///
/// ```
/// use your_crate::process;
///
/// let result = process("hello");
/// assert_eq!(result, "HELLO");
/// ```
///
/// # Errors
///
/// Returns an error if the input is empty.
pub fn process(input: &str) -> Result<String, Error> {
    // Implementation
}
```

<!-- RUST:END -->


<!-- TYPESCRIPT:START -->
# TypeScript Project Rules

## TypeScript Configuration

**CRITICAL**: Use TypeScript 5.3+ with strict mode enabled.

- **Version**: TypeScript 5.3+
- **Mode**: Strict mode enabled
- **Target**: ES2022 or later
- **Module**: ESNext with Node16 module resolution

### tsconfig.json Requirements

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Type check
npm run type-check  # or: tsc --noEmit

# 2. Lint (MUST pass with no warnings)
npm run lint

# 3. Format code
npm run format

# 4. Run all tests (MUST pass 100%)
npm test

# 5. Check coverage (MUST meet threshold)
npm run test:coverage
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Linting

- Use ESLint with TypeScript plugin
- Configuration in `eslint.config.js` or `.eslintrc.json`
- Must pass with no warnings: `eslint src/**/*.ts`
- Fix automatically when possible: `eslint src/**/*.ts --fix`

Example ESLint config:
```json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "warn"
  }
}
```

### Formatting

- Use Prettier for code formatting
- Configuration in `.prettierrc.json`
- Integrate with ESLint for consistency
- Format before committing: `prettier --write "src/**/*.ts"`

Example Prettier config:
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}
```

### Testing

- **Framework**: Vitest (recommended) or Jest
- **Location**: `/tests` directory or co-located `*.test.ts` files
- **Coverage**: Must meet project threshold (default 95%)
- **Watch Mode**: Use `vitest` or `vitest --watch` for development
- **CI Mode**: **CRITICAL** - Default `npm test` command MUST include `--run` flag
  - This prevents Vitest from entering watch mode, which never terminates
  - In `package.json`: `"test": "vitest --run"`
  - In CI workflows: use `npm test` (do NOT add `--run` argument)
  - For manual development, use `npm run test:watch`

Example test structure:
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { myFunction } from './my-module';

describe('myFunction', () => {
  beforeEach(() => {
    // Setup
  });

  afterEach(() => {
    // Cleanup
  });

  it('should handle valid input', () => {
    const result = myFunction('input');
    expect(result).toBe('expected');
  });

  it('should throw on invalid input', () => {
    expect(() => myFunction('')).toThrow('Invalid input');
  });
});
```

## Package Management

**CRITICAL**: Use consistent package manager across team.

- **Default**: npm (most compatible, built-in)
- **Alternative**: pnpm (fast, disk-efficient) or yarn
- **Lockfile**: Always commit lockfile (`package-lock.json`, `pnpm-lock.yaml`, or `yarn.lock`)
- **Workspaces**: Use for monorepos
- **CI/CD**: Update GitHub Actions workflows to match your package manager (see workflow comments)

### Dependencies

1. **Check for latest versions**:
   - Use Context7 MCP tool if available
   - Check npm registry: `npm view <package> versions`
   - Review changelog for breaking changes

2. **Dependency Guidelines**:
   - ✅ Use exact versions for applications (`"1.2.3"`)
   - ✅ Use semver for libraries (`"^1.2.3"`)
   - ✅ Keep dependencies updated regularly
   - ✅ Use `npm audit` or `pnpm audit` for security
   - ❌ Don't use deprecated packages
   - ❌ Don't add unnecessary dependencies

3. **Document new dependencies**:
   - Update CHANGELOG.md
   - Document why dependency was added
   - Note any peer dependencies

## Type Safety

- **No `any`**: Avoid `any` type - use `unknown` and type guards
- **Strict null checks**: Handle null/undefined explicitly
- **Type assertions**: Minimize use of `as` - prefer type guards
- **Generics**: Use for reusable type-safe code

Example type-safe code:
```typescript
// Good: Type guard
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function process(input: unknown): string {
  if (isString(input)) {
    return input.toUpperCase();
  }
  throw new Error('Invalid input');
}

// Bad: Type assertion
function processUnsafe(input: unknown): string {
  return (input as string).toUpperCase(); // Runtime error if not string
}
```

## Error Handling

- Create custom error classes
- Use type guards for error checking
- Document errors in JSDoc/TSDoc
- Never swallow errors silently

Example:
```typescript
export class ValidationError extends Error {
  constructor(
    message: string,
    public readonly field: string
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export function validate(data: unknown): Data {
  if (!isValidData(data)) {
    throw new ValidationError('Invalid data structure', 'data');
  }
  return data;
}
```

## Documentation

- **JSDoc/TSDoc**: Document public APIs
- **Examples**: Include usage examples
- **Type exports**: Export types for library consumers
- **README**: Include API documentation

Example:
```typescript
/**
 * Processes the input data and returns a formatted result.
 *
 * @param input - The input string to process
 * @param options - Optional processing options
 * @returns The processed string in uppercase
 * @throws {ValidationError} If input is empty
 *
 * @example
 * ```typescript
 * const result = process('hello', { trim: true });
 * console.log(result); // 'HELLO'
 * ```
 */
export function process(
  input: string,
  options?: ProcessOptions
): string {
  // Implementation
}
```

## Project Structure

```
project/
├── package.json        # Package manifest
├── tsconfig.json       # TypeScript config
├── vitest.config.ts    # Test config
├── README.md           # Project overview (allowed in root)
├── CHANGELOG.md        # Version history (allowed in root)
├── AGENTS.md          # AI assistant rules (allowed in root)
├── LICENSE            # Project license (allowed in root)
├── CONTRIBUTING.md    # Contribution guidelines (allowed in root)
├── CODE_OF_CONDUCT.md # Code of conduct (allowed in root)
├── SECURITY.md        # Security policy (allowed in root)
├── src/
│   ├── index.ts        # Main entry point
│   ├── types.ts        # Type definitions
│   └── ...
├── tests/              # Test files
├── dist/               # Compiled output (gitignored)
└── docs/               # Project documentation
```

## Module System

- Use ES modules (`import`/`export`)
- Set `"type": "module"` in `package.json`
- Use `.js` extensions in imports for Node.js compatibility
- Configure `moduleResolution: "node"` in tsconfig.json

Example:
```typescript
// Good: ES modules with .js extension
import { myFunction } from './my-module.js';

export { myFunction };
export default class MyClass {}
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`typescript-test.yml`):
   - Test on ubuntu-latest, windows-latest, macos-latest
   - Use Vitest for fast execution
   - Upload coverage reports

2. **Linting** (`typescript-lint.yml`):
   - Type check: `tsc --noEmit`
   - ESLint: `eslint src/**/*.ts`
   - Prettier: `prettier --check "src/**/*.ts"`

3. **Build** (`typescript-build.yml`):
   - Build: `npm run build`
   - Verify no type errors
   - Check output artifacts

## Package Publication

### Publishing to npm

**Prerequisites:**
1. Create npm account at https://www.npmjs.com
2. Generate npm token (Account Settings → Access Tokens → Generate New Token)
3. Add `NPM_TOKEN` to GitHub repository secrets

**package.json Configuration:**

```json
{
  "name": "@your-org/package-name",
  "version": "1.0.0",
  "description": "Package description",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "scripts": {
    "prepublishOnly": "npm run build && npm test"
  },
  "keywords": ["your", "keywords"],
  "author": "Your Name",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/your-org/package-name"
  }
}
```

**Publishing Workflow:**

1. Update version: `npm version patch|minor|major`
2. Create release tag: `git push --tags`
3. GitHub Actions automatically publishes to npm
4. Or manual publish: `npm publish --access public`

**Publishing Checklist:**

- ✅ All tests passing
- ✅ Code linted and formatted
- ✅ Version updated in package.json
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ Type declarations generated
- ✅ Package size reasonable (`npm pack` to check)
- ✅ .npmignore or package.json "files" configured
- ✅ Provenance enabled for security

**npm Provenance:**

Enable provenance for better security and transparency:
```bash
npm publish --provenance --access public
```

This links your package to its source code and build process.

<!-- TYPESCRIPT:END -->


<!-- PYTHON:START -->
# Python Project Rules

## Python Version

**CRITICAL**: Use Python 3.11+ for modern features and performance.

- **Minimum Version**: Python 3.11+
- **Recommended**: Python 3.12+
- **Type Hints**: Required for all public APIs

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
ruff format .

# 2. Lint (MUST pass with no warnings)
ruff check .

# 3. Type check
mypy .

# 4. Run all tests (MUST pass 100%)
pytest

# 5. Check coverage (MUST meet threshold)
pytest --cov=. --cov-report=term --cov-report=html
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Formatting

- Use `ruff format` (fast, modern) or `black` (traditional)
- Line length: 100 characters (configurable)
- Consistent formatting across entire project
- Format before committing

Configuration in `pyproject.toml`:
```toml
[tool.ruff]
line-length = 100
target-version = "py311"

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

### Linting

- Use `ruff check` (fast, comprehensive) or `ruff` + `flake8`
- Fix all linting errors before committing
- Document any disabled rules with justification

Configuration in `pyproject.toml`:
```toml
[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "UP", "B", "A", "C4", "SIM"]
ignore = ["E501"]  # Line too long (handled by formatter)

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]  # Allow assert in tests
```

### Type Checking

- Use `mypy` for static type checking
- All public APIs must have type hints
- Use `typing` module for complex types
- Gradual typing allowed for legacy code

Configuration in `pyproject.toml`:
```toml
[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

Example:
```python
from typing import Optional, List, Dict, Any

def process_data(
    input_data: str,
    options: Optional[Dict[str, Any]] = None
) -> List[str]:
    """Process input data and return results."""
    # Implementation
    return []
```

### Testing

- **Framework**: pytest
- **Location**: `/tests` directory
- **Coverage**: Must meet project threshold (default 95%)
- **Fixtures**: Use pytest fixtures for setup/teardown
- **Parametrize**: Use `@pytest.mark.parametrize` for multiple test cases

Example test structure:
```python
import pytest
from mymodule import process_data

@pytest.fixture
def sample_data():
    """Provide sample data for tests."""
    return "test input"

def test_process_data_valid_input(sample_data):
    """Test process_data with valid input."""
    result = process_data(sample_data)
    assert result == ["expected"]

@pytest.mark.parametrize("input_val,expected", [
    ("hello", ["HELLO"]),
    ("world", ["WORLD"]),
])
def test_process_data_parametrized(input_val, expected):
    """Test multiple input cases."""
    result = process_data(input_val)
    assert result == expected
```

## Dependency Management

**CRITICAL**: Use modern dependency management tools.

### Recommended: Poetry

```toml
[tool.poetry]
name = "myproject"
version = "0.1.0"
description = ""
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.11"
requests = "^2.31.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
mypy = "^1.5.0"
ruff = "^0.1.0"
```

Commands:
```bash
poetry install              # Install dependencies
poetry add requests         # Add dependency
poetry add --group dev pytest  # Add dev dependency
poetry update               # Update dependencies
```

### Alternative: pip-tools

```
# requirements.in
requests>=2.31.0
pydantic>=2.0.0

# requirements-dev.in
-r requirements.in
pytest>=7.4.0
mypy>=1.5.0
```

Commands:
```bash
pip-compile requirements.in
pip-compile requirements-dev.in
pip-sync requirements-dev.txt
```

### Dependency Guidelines

1. **Check for latest versions**:
   - Use Context7 MCP tool if available
   - Check PyPI: `pip index versions <package>`
   - Review changelog for breaking changes

2. **Version pinning**:
   - ✅ Pin exact versions in applications
   - ✅ Use ranges in libraries (`>=1.0,<2.0`)
   - ✅ Keep dependencies updated regularly
   - ❌ Don't use outdated packages with security issues

## Error Handling

- Use specific exception types
- Create custom exceptions when needed
- Document exceptions in docstrings
- Never use bare `except:`

Example:
```python
class ValidationError(Exception):
    """Raised when data validation fails."""
    
    def __init__(self, message: str, field: str):
        super().__init__(message)
        self.field = field

def validate_data(data: dict[str, Any]) -> None:
    """
    Validate input data.
    
    Args:
        data: The data to validate
        
    Raises:
        ValidationError: If validation fails
    """
    if not isinstance(data, dict):
        raise ValidationError("Data must be a dictionary", "data")
```

## Documentation

- **Docstrings**: Google or NumPy style
- **Type hints**: Required for public APIs
- **README**: Include installation and usage
- **API docs**: Consider Sphinx for large projects

Example (Google style):
```python
def process_data(input_data: str, options: dict[str, Any] | None = None) -> list[str]:
    """
    Process input data and return results.
    
    Args:
        input_data: The input string to process
        options: Optional processing options
        
    Returns:
        A list of processed strings
        
    Raises:
        ValidationError: If input_data is empty
        
    Examples:
        >>> process_data("hello")
        ['HELLO']
        >>> process_data("world", {"lowercase": True})
        ['world']
    """
    # Implementation
    return []
```

## Project Structure

```
project/
├── pyproject.toml      # Project metadata and dependencies
├── README.md           # Project overview (allowed in root)
├── CHANGELOG.md        # Version history (allowed in root)
├── AGENTS.md          # AI assistant rules (allowed in root)
├── LICENSE            # Project license (allowed in root)
├── CONTRIBUTING.md    # Contribution guidelines (allowed in root)
├── CODE_OF_CONDUCT.md # Code of conduct (allowed in root)
├── SECURITY.md        # Security policy (allowed in root)
├── src/
│   └── mypackage/
│       ├── __init__.py
│       ├── module.py
│       └── py.typed    # PEP 561 marker for type hints
├── tests/              # Test files
│   ├── __init__.py
│   └── test_module.py
└── docs/               # Documentation
```

## Async Programming

- Use `asyncio` for async code
- Type hints: `async def func() -> Coroutine`
- Testing: Use `pytest-asyncio`

Example:
```python
import asyncio
from typing import List

async def fetch_data(url: str) -> dict[str, Any]:
    """Fetch data asynchronously."""
    # Implementation
    return {}

async def main() -> None:
    """Main async function."""
    results = await asyncio.gather(
        fetch_data("url1"),
        fetch_data("url2"),
    )
    print(results)

if __name__ == "__main__":
    asyncio.run(main())
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`python-test.yml`):
   - Test on ubuntu-latest, windows-latest, macos-latest
   - Test on Python 3.11, 3.12
   - Upload coverage reports

2. **Linting** (`python-lint.yml`):
   - Format check: `ruff format --check .`
   - Lint: `ruff check .`
   - Type check: `mypy .`

3. **Security** (`python-security.yml`):
   - Check for vulnerabilities: `pip-audit`
   - Scan dependencies: `safety check`

## Package Publication

### Publishing to PyPI

**Prerequisites:**
1. Create account at https://pypi.org
2. Enable 2FA for security
3. Configure trusted publishing (recommended) or create API token
4. For trusted publishing: Add GitHub as publisher in PyPI settings

**pyproject.toml Configuration:**

```toml
[build-system]
requires = ["setuptools>=68.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "your-package-name"
version = "1.0.0"
description = "A short description of your package"
readme = "README.md"
requires-python = ">=3.11"
license = {text = "MIT"}
authors = [
    {name = "Your Name", email = "your.email@example.com"}
]
keywords = ["your", "keywords"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
dependencies = [
    "requests>=2.31.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-cov>=4.1.0",
    "ruff>=0.1.0",
    "mypy>=1.7.0",
    "black>=23.12.0",
]

[project.urls]
Homepage = "https://github.com/your-org/your-package"
Documentation = "https://your-package.readthedocs.io"
Repository = "https://github.com/your-org/your-package"
"Bug Tracker" = "https://github.com/your-org/your-package/issues"

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools.package-data]
your_package = ["py.typed"]
```

### PEP 625 Package Naming Convention

**CRITICAL**: Package names must be normalized according to PEP 625.

PyPI requires source distribution filenames to use normalized package names (underscores instead of hyphens).

**Naming Rules:**

1. **Package name in `pyproject.toml`**: Use underscores (`_`)
   ```toml
   [project]
   name = "my_package_name"  # Correct
   # NOT: name = "my-package-name"  # Will cause deprecation warning
   ```

2. **Package directory**: Must match with underscores
   ```
   src/
   └── my_package_name/     # Correct
       ├── __init__.py
       └── ...
   ```

3. **Import statement**: Uses underscores
   ```python
   import my_package_name
   from my_package_name import something
   ```

4. **Distribution filename**: Will be `my_package_name-1.0.0.tar.gz` ✅

**Common Issue:**

If you use hyphens in the package name, PyPI will reject new uploads:
```toml
# ❌ WRONG - Will fail PEP 625 compliance
[project]
name = "my-package-name"

# Result: my-package-name-1.0.0.tar.gz (non-compliant)
# PyPI Error: "Filename does not contain normalized project name"
```

**Correct Approach:**
```toml
# ✅ CORRECT - PEP 625 compliant
[project]
name = "my_package_name"

# Result: my_package_name-1.0.0.tar.gz (compliant)
# PyPI: Accepts upload without warnings
```

**Migration from Hyphenated Names:**

If you previously published with hyphens:

1. Update `pyproject.toml` and `setup.py` to use underscores
2. Existing uploads remain on PyPI (no action needed)
3. Future uploads will use normalized name
4. PyPI will automatically redirect:
   - `pip install my-package-name` → works (auto-normalized)
   - `pip install my_package_name` → works (canonical form)
5. Import statement unchanged: `import my_package_name`

**Reference**: [PEP 625 - File name of a Source Distribution](https://peps.python.org/pep-0625/)

**Publishing Workflow:**

1. Update version in pyproject.toml
2. Update CHANGELOG.md
3. Run quality checks:
   ```bash
   ruff check .
   ruff format --check .
   mypy .
   pytest
   ```
4. Build package:
   ```bash
   python -m build
   twine check dist/*
   ```
5. Test on Test PyPI (optional):
   ```bash
   twine upload --repository testpypi dist/*
   ```
6. Create git tag: `git tag v1.0.0 && git push --tags`
7. GitHub Actions automatically publishes to PyPI
8. Or manual publish: `twine upload dist/*`

**Publishing Checklist:**

- ✅ All tests passing (`pytest`)
- ✅ Type checking passes (`mypy .`)
- ✅ Linting passes (`ruff check .`)
- ✅ Code formatted (`ruff format .`)
- ✅ Version updated in pyproject.toml
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ LICENSE file present
- ✅ **Package name uses underscores (PEP 625 compliant)**
- ✅ `py.typed` marker for type hints
- ✅ Package builds successfully (`python -m build`)
- ✅ Package checks pass (`twine check dist/*`)
- ✅ Manifest complete (`check-manifest`)
- ✅ **Verify dist filename**: `my_package-1.0.0.tar.gz` (underscores) ✅

**Trusted Publishing (Recommended):**

PyPI trusted publishing eliminates the need for API tokens:

1. Go to PyPI → Your Account → Publishing
2. Add a new pending publisher:
   - PyPI Project Name: `your-package-name`
   - Owner: `your-github-org`
   - Repository: `your-repo-name`
   - Workflow: `python-publish.yml`
   - Environment: `release` (optional)

3. GitHub Actions will authenticate automatically using OIDC

**Versioning:**

Use semantic versioning and consider:
- **Automated versioning**: Use tools like `bump2version` or `setuptools_scm`
- **Version from git tags**: Configure `setuptools_scm` in pyproject.toml:

```toml
[build-system]
requires = ["setuptools>=68.0", "setuptools_scm>=8.0"]

[tool.setuptools_scm]
version_file = "src/your_package/_version.py"
```

**Type Hints:**

Include `py.typed` marker for PEP 561 compliance:
```bash
touch src/your_package/py.typed
```

This tells type checkers your package includes type information.

<!-- PYTHON:END -->


<!-- GO:START -->
# Go Project Rules

## Go Version

**CRITICAL**: Use Go 1.21+ for modern features and performance.

- **Minimum Version**: Go 1.21+
- **Recommended**: Go 1.22+
- **Module System**: Go modules enabled

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
gofmt -w .
go fmt ./...

# 2. Lint (MUST pass with no warnings)
golangci-lint run

# 3. Vet code
go vet ./...

# 4. Run all tests (MUST pass 100%)
go test ./... -v

# 5. Check coverage (MUST meet threshold)
go test ./... -cover -coverprofile=coverage.out
go tool cover -func=coverage.out
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Formatting

- Use `gofmt` or `goimports` for code formatting
- Standard Go formatting is non-negotiable
- Format before committing: `gofmt -w .`
- CI must check formatting: `gofmt -l . | wc -l` should be 0

### Linting

- Use `golangci-lint` with recommended linters
- Configuration in `.golangci.yml`
- Must pass with no issues
- Enable linters: govet, errcheck, staticcheck, gosimple, unused

Example `.golangci.yml`:
```yaml
linters:
  enable:
    - govet
    - errcheck
    - staticcheck
    - gosimple
    - unused
    - gosec
    - gocyclo
    - gofmt
    - goimports
    
linters-settings:
  gocyclo:
    min-complexity: 15
  govet:
    check-shadowing: true
    
issues:
  exclude-use-default: false
```

### Testing

- **Framework**: Standard testing package
- **Location**: `*_test.go` files in same package
- **Coverage**: Must meet project threshold (default 95%)
- **Table-Driven Tests**: Use for multiple test cases
- **Subtests**: Use `t.Run()` for organized tests

Example test structure:
```go
package mypackage

import (
    "testing"
)

func TestMyFunction(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        want    string
        wantErr bool
    }{
        {"valid input", "test", "TEST", false},
        {"empty input", "", "", true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := MyFunction(tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("MyFunction() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if got != tt.want {
                t.Errorf("MyFunction() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

## Dependency Management

**CRITICAL**: Use Go modules for dependency management.

### go.mod and go.sum

```bash
# Initialize module
go mod init github.com/username/project

# Add dependency
go get github.com/package/name@latest

# Update dependencies
go get -u ./...
go mod tidy

# Verify dependencies
go mod verify
```

### Dependency Guidelines

1. **Check for latest versions**:
   - Use Context7 MCP tool if available
   - Check pkg.go.dev for documentation
   - Review changelog for breaking changes

2. **Version Selection**:
   - ✅ Use latest stable versions
   - ✅ Pin to specific versions for reproducibility
   - ✅ Keep dependencies updated regularly
   - ✅ Use `go mod tidy` to remove unused
   - ❌ Don't use deprecated packages
   - ❌ Don't vendor unless necessary

## Error Handling

- Always return errors, don't panic
- Use custom error types with `fmt.Errorf`
- Wrap errors with context: `fmt.Errorf("operation failed: %w", err)`
- Check all errors, never ignore
- Use `errors.Is()` and `errors.As()` for error checking

Example:
```go
package mypackage

import (
    "errors"
    "fmt"
)

var (
    ErrInvalidInput = errors.New("invalid input")
    ErrNotFound     = errors.New("not found")
)

func ProcessData(input string) (string, error) {
    if input == "" {
        return "", fmt.Errorf("process data: %w", ErrInvalidInput)
    }
    
    result, err := doSomething(input)
    if err != nil {
        return "", fmt.Errorf("failed to process: %w", err)
    }
    
    return result, nil
}
```

## Documentation

- **Package docs**: Use package comments
- **Function docs**: Document all exported functions
- **Examples**: Include in doc comments (will run as tests)
- **Run godoc**: `go doc -all`

Example:
```go
// Package auth provides authentication and authorization utilities.
//
// This package implements JWT-based authentication following OAuth 2.0
// standards. All functions are thread-safe.
package auth

// Authenticate verifies user credentials and returns a JWT token.
//
// The token is valid for 24 hours and includes the user's ID and roles.
//
// Example:
//
//	token, err := Authenticate("user@example.com", "password")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	fmt.Println("Token:", token)
//
// Returns an error if credentials are invalid or database is unreachable.
func Authenticate(email, password string) (string, error) {
    // Implementation
    return "", nil
}
```

## Project Structure

```
project/
├── go.mod              # Module definition
├── go.sum              # Dependency checksums (commit this)
├── README.md           # Project overview (allowed in root)
├── CHANGELOG.md        # Version history (allowed in root)
├── AGENTS.md          # AI assistant rules (allowed in root)
├── LICENSE            # Project license (allowed in root)
├── CONTRIBUTING.md    # Contribution guidelines (allowed in root)
├── CODE_OF_CONDUCT.md # Code of conduct (allowed in root)
├── SECURITY.md        # Security policy (allowed in root)
├── cmd/
│   └── myapp/
│       └── main.go     # Application entry point
├── internal/           # Private packages
│   └── module/
│       ├── module.go
│       └── module_test.go
├── pkg/                # Public packages
│   └── api/
│       ├── api.go
│       └── api_test.go
├── tests/              # Integration tests
└── docs/               # Documentation
```

## Concurrency

- Use goroutines for concurrent operations
- Use channels for communication
- Use `sync.WaitGroup` for synchronization
- Use context for cancellation and timeouts
- Avoid shared memory, prefer channels

Example:
```go
func ProcessConcurrently(items []string) ([]Result, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    results := make(chan Result, len(items))
    errors := make(chan error, len(items))
    
    var wg sync.WaitGroup
    for _, item := range items {
        wg.Add(1)
        go func(item string) {
            defer wg.Done()
            
            select {
            case <-ctx.Done():
                errors <- ctx.Err()
                return
            default:
                result, err := processItem(item)
                if err != nil {
                    errors <- err
                    return
                }
                results <- result
            }
        }(item)
    }
    
    wg.Wait()
    close(results)
    close(errors)
    
    // Collect results
    var finalResults []Result
    for r := range results {
        finalResults = append(finalResults, r)
    }
    
    // Check for errors
    for err := range errors {
        if err != nil {
            return nil, err
        }
    }
    
    return finalResults, nil
}
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`go-test.yml`):
   - Test on ubuntu-latest, windows-latest, macos-latest
   - Test on Go 1.21, 1.22
   - Upload coverage reports

2. **Linting** (`go-lint.yml`):
   - Format check: `gofmt -l .`
   - Lint: `golangci-lint run`
   - Vet: `go vet ./...`

3. **Build** (`go-build.yml`):
   - Build: `go build ./...`
   - Verify binaries work

## Module Publication

### Publishing Go Modules

Go modules are published via Git tags and automatically indexed by pkg.go.dev.

**Prerequisites:**
1. Public Git repository (GitHub, GitLab, etc.)
2. Proper go.mod configuration
3. Semantic versioning tags

**go.mod Configuration:**

```go
module github.com/your-org/your-module

go 1.22

require (
    github.com/example/dependency v1.2.3
)
```

**Publishing Workflow:**

1. Ensure go.mod is correct:
   ```bash
   go mod tidy
   go mod verify
   ```

2. Run quality checks:
   ```bash
   go fmt ./...
   go vet ./...
   golangci-lint run
   go test -v -race ./...
   ```

3. Create semantic version tag:
   ```bash
   git tag v1.0.0
   git push origin v1.0.0
   ```

4. pkg.go.dev automatically indexes the module
5. Verify at: `https://pkg.go.dev/github.com/your-org/your-module@v1.0.0`

**Publishing Checklist:**

- ✅ All tests passing (`go test ./...`)
- ✅ No race conditions (`go test -race ./...`)
- ✅ Code formatted (`go fmt ./...`)
- ✅ No vet warnings (`go vet ./...`)
- ✅ golangci-lint passes
- ✅ go.mod is tidy (`go mod tidy`)
- ✅ README.md with examples
- ✅ LICENSE file present
- ✅ Semantic version tag (v1.0.0)
- ✅ CHANGELOG.md updated

**Semantic Versioning:**

Go uses semantic versioning strictly:

- **v1.0.0** - First stable release
- **v1.1.0** - New features (backwards compatible)
- **v1.0.1** - Bug fixes
- **v2.0.0** - Breaking changes (requires /v2 in module path)

**Major Version Updates (v2+):**

For v2 and above, update module path:

```go
// go.mod
module github.com/your-org/your-module/v2

go 1.22
```

**Module Documentation:**

Write godoc-compatible comments:

```go
// Package yourmodule provides functionality for X, Y, and Z.
//
// Basic usage:
//
//	import "github.com/your-org/your-module"
//
//	result, err := yourmodule.Process("input")
//	if err != nil {
//	    log.Fatal(err)
//	}
package yourmodule

// Process handles the input and returns a result.
//
// Example:
//
//	result, err := Process("hello")
//	if err != nil {
//	    return err
//	}
//	fmt.Println(result)
func Process(input string) (string, error) {
    // Implementation
}
```

**GOPROXY:**

Go modules are automatically cached in public proxies:
- https://proxy.golang.org (default)
- https://goproxy.io
- https://goproxy.cn

No manual publication needed!

**Retraction:**

To retract a published version:

```go
// go.mod
retract v1.0.5 // Critical bug in processing
```

<!-- GO:END -->


<!-- JAVA:START -->
# Java Project Rules

## Java Version

**CRITICAL**: Use Java 17 LTS or Java 21 LTS for modern features and long-term support.

- **Minimum Version**: Java 17 LTS
- **Recommended**: Java 21 LTS
- **Build Tool**: Maven or Gradle

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# For Maven projects:

# 1. Format code
mvn spotless:apply

# 2. Lint and static analysis
mvn checkstyle:check
mvn pmd:check

# 3. Run all tests (MUST pass 100%)
mvn test

# 4. Check coverage (MUST meet threshold)
mvn jacoco:report
mvn jacoco:check

# For Gradle projects:

# 1. Format code
./gradlew spotlessApply

# 2. Lint and check
./gradlew checkstyleMain checkstyleTest

# 3. Run tests
./gradlew test

# 4. Check coverage
./gradlew jacocoTestReport jacocoTestCoverageVerification
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Formatting

- Use Spotless or Google Java Format
- Consistent formatting across entire project
- Format before committing

Maven configuration (`pom.xml`):
```xml
<plugin>
    <groupId>com.diffplug.spotless</groupId>
    <artifactId>spotless-maven-plugin</artifactId>
    <version>2.40.0</version>
    <configuration>
        <java>
            <googleJavaFormat>
                <version>1.17.0</version>
                <style>GOOGLE</style>
            </googleJavaFormat>
        </java>
    </configuration>
</plugin>
```

Gradle configuration (`build.gradle`):
```gradle
plugins {
    id 'com.diffplug.spotless' version '6.23.0'
}

spotless {
    java {
        googleJavaFormat('1.17.0').aosp()
    }
}
```

### Linting

- Use Checkstyle for style checks
- Use PMD for code quality
- Use SpotBugs for bug detection
- Configure in `checkstyle.xml`, `pmd.xml`

### Testing

- **Framework**: JUnit 5 (JUnit Jupiter)
- **Location**: `src/test/java`
- **Coverage**: Must meet project threshold (default 95%)
- **Assertions**: Use AssertJ or JUnit assertions
- **Mocking**: Use Mockito when needed

Example test structure:
```java
package com.example.myapp;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import static org.assertj.core.api.Assertions.*;

class UserServiceTest {
    
    private UserService userService;
    
    @BeforeEach
    void setUp() {
        userService = new UserService();
    }
    
    @Test
    @DisplayName("Should create user with valid data")
    void shouldCreateUserWithValidData() {
        // Given
        UserInput input = new UserInput("test@example.com", "password");
        
        // When
        User user = userService.createUser(input);
        
        // Then
        assertThat(user).isNotNull();
        assertThat(user.getEmail()).isEqualTo("test@example.com");
    }
    
    @Test
    @DisplayName("Should throw exception for invalid email")
    void shouldThrowExceptionForInvalidEmail() {
        // Given
        UserInput input = new UserInput("invalid", "password");
        
        // When/Then
        assertThatThrownBy(() -> userService.createUser(input))
            .isInstanceOf(ValidationException.class)
            .hasMessageContaining("Invalid email");
    }
}
```

## Dependency Management

**CRITICAL**: Use Maven or Gradle with dependency management.

### Maven (pom.xml)

```xml
<properties>
    <java.version>21</java.version>
    <maven.compiler.source>21</maven.compiler.source>
    <maven.compiler.target>21</maven.compiler.target>
</properties>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
        <version>3.2.0</version>
    </dependency>
    
    <!-- Testing -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.1</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### Gradle (build.gradle)

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testImplementation 'org.assertj:assertj-core:3.24.2'
}

test {
    useJUnitPlatform()
}
```

### Dependency Guidelines

1. **Check for latest versions**:
   - Use Context7 MCP tool if available
   - Check Maven Central for latest releases
   - Review changelog for breaking changes

2. **Version Management**:
   - ✅ Use BOM (Bill of Materials) for version consistency
   - ✅ Keep dependencies updated regularly
   - ✅ Use dependency management in parent POM
   - ❌ Don't use SNAPSHOT in production
   - ❌ Don't use vulnerable dependencies

## Error Handling

- Use exceptions for exceptional cases only
- Create custom exceptions extending RuntimeException or Exception
- Use try-with-resources for resource management
- Log errors appropriately
- Never catch and ignore exceptions

Example:
```java
public class UserService {
    
    public User createUser(UserInput input) throws ValidationException {
        if (input.getEmail() == null || input.getEmail().isEmpty()) {
            throw new ValidationException("Email is required");
        }
        
        try {
            return userRepository.save(input);
        } catch (DataAccessException e) {
            throw new ServiceException("Failed to create user", e);
        }
    }
}

public class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }
}
```

## Documentation

- **Javadoc**: Document all public APIs
- **Package Info**: Create `package-info.java`
- **Examples**: Include usage examples
- **Generate**: `mvn javadoc:javadoc` or `./gradlew javadoc`

Example:
```java
/**
 * Processes user data and returns validated result.
 *
 * <p>This method validates the input data according to business rules
 * and returns a validated User object. If validation fails, it throws
 * a ValidationException with details about the failure.
 *
 * @param input the user input data to process
 * @return validated User object
 * @throws ValidationException if input validation fails
 * @throws ServiceException if database operation fails
 *
 * @see UserInput
 * @see ValidationException
 *
 * @since 1.0.0
 */
public User processUser(UserInput input) throws ValidationException {
    // Implementation
    return null;
}
```

## Project Structure

```
project/
├── pom.xml             # Maven config (or build.gradle)
├── README.md           # Project overview (allowed in root)
├── CHANGELOG.md        # Version history (allowed in root)
├── AGENTS.md          # AI assistant rules (allowed in root)
├── LICENSE            # Project license (allowed in root)
├── CONTRIBUTING.md    # Contribution guidelines (allowed in root)
├── CODE_OF_CONDUCT.md # Code of conduct (allowed in root)
├── SECURITY.md        # Security policy (allowed in root)
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/example/
│   │   │       ├── Application.java
│   │   │       ├── controller/
│   │   │       ├── service/
│   │   │       └── repository/
│   │   └── resources/
│   │       └── application.properties
│   └── test/
│       ├── java/
│       │   └── com/example/
│       │       ├── service/
│       │       └── repository/
│       └── resources/
├── target/             # Build output (gitignored)
└── docs/               # Documentation
```

## Modern Java Features

### Records (Java 14+)

```java
public record User(String email, String name, LocalDateTime createdAt) {
    // Compact constructor
    public User {
        if (email == null || email.isEmpty()) {
            throw new IllegalArgumentException("Email required");
        }
    }
}
```

### Pattern Matching (Java 17+)

```java
public String processValue(Object value) {
    return switch (value) {
        case String s -> "String: " + s;
        case Integer i -> "Integer: " + i;
        case null -> "Null value";
        default -> "Unknown type";
    };
}
```

### Sealed Classes (Java 17+)

```java
public sealed interface Result<T, E> permits Success, Failure {
    // Interface definition
}

public record Success<T, E>(T value) implements Result<T, E> {}
public record Failure<T, E>(E error) implements Result<T, E> {}
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`java-test.yml`):
   - Test on ubuntu-latest, windows-latest
   - Test on Java 17, 21
   - Upload coverage to Codecov

2. **Linting** (`java-lint.yml`):
   - Checkstyle checks
   - PMD analysis
   - SpotBugs detection

3. **Build** (`java-build.yml`):
   - Build with Maven/Gradle
   - Verify JAR creation
   - Check dependencies

## Package Publication

### Publishing to Maven Central

**Prerequisites:**
1. Sonatype OSSRH account (https://issues.sonatype.org)
2. GPG key for signing
3. Group ID approval (e.g., `io.github.username`)
4. Add credentials to GitHub Secrets

**Maven (pom.xml) Configuration:**

```xml
<project>
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>io.github.your-username</groupId>
    <artifactId>your-library</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <name>Your Library</name>
    <description>A concise description of your library</description>
    <url>https://github.com/your-org/your-library</url>
    
    <licenses>
        <license>
            <name>MIT License</name>
            <url>https://opensource.org/licenses/MIT</url>
        </license>
    </licenses>
    
    <developers>
        <developer>
            <name>Your Name</name>
            <email>your.email@example.com</email>
            <organization>Your Organization</organization>
            <organizationUrl>https://your-org.com</organizationUrl>
        </developer>
    </developers>
    
    <scm>
        <connection>scm:git:git://github.com/your-org/your-library.git</connection>
        <developerConnection>scm:git:ssh://github.com:your-org/your-library.git</developerConnection>
        <url>https://github.com/your-org/your-library/tree/main</url>
    </scm>
    
    <distributionManagement>
        <repository>
            <id>ossrh</id>
            <url>https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/</url>
        </repository>
    </distributionManagement>
    
    <build>
        <plugins>
            <!-- Source JAR -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>3.3.0</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar-no-fork</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Javadoc JAR -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>3.6.3</version>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <!-- GPG Signing -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-gpg-plugin</artifactId>
                <version>3.1.0</version>
                <executions>
                    <execution>
                        <id>sign-artifacts</id>
                        <phase>verify</phase>
                        <goals>
                            <goal>sign</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

**Gradle (build.gradle.kts) Configuration:**

```kotlin
plugins {
    `java-library`
    `maven-publish`
    signing
    id("io.github.gradle-nexus.publish-plugin") version "1.3.0"
}

group = "io.github.your-username"
version = "1.0.0"

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    withSourcesJar()
    withJavadocJar()
}

publishing {
    publications {
        create<MavenPublication>("mavenJava") {
            from(components["java"])
            
            pom {
                name.set("Your Library")
                description.set("A concise description of your library")
                url.set("https://github.com/your-org/your-library")
                
                licenses {
                    license {
                        name.set("MIT License")
                        url.set("https://opensource.org/licenses/MIT")
                    }
                }
                
                developers {
                    developer {
                        id.set("your-username")
                        name.set("Your Name")
                        email.set("your.email@example.com")
                    }
                }
                
                scm {
                    connection.set("scm:git:git://github.com/your-org/your-library.git")
                    developerConnection.set("scm:git:ssh://github.com:your-org/your-library.git")
                    url.set("https://github.com/your-org/your-library")
                }
            }
        }
    }
}

signing {
    sign(publishing.publications["mavenJava"])
}

nexusPublishing {
    repositories {
        sonatype {
            nexusUrl.set(uri("https://s01.oss.sonatype.org/service/local/"))
            snapshotRepositoryUrl.set(uri("https://s01.oss.sonatype.org/content/repositories/snapshots/"))
        }
    }
}
```

**Publishing Workflow:**

1. Update version in pom.xml/build.gradle
2. Update CHANGELOG.md
3. Run quality checks:
   ```bash
   # Maven
   mvn clean test
   mvn checkstyle:check
   mvn pmd:check
   
   # Gradle
   ./gradlew test
   ./gradlew checkstyleMain
   ./gradlew pmdMain
   ```

4. Create git tag: `git tag v1.0.0 && git push --tags`
5. GitHub Actions automatically publishes to Maven Central
6. Or manual publish:
   ```bash
   # Maven
   mvn clean deploy -P release
   
   # Gradle
   ./gradlew publishToSonatype closeAndReleaseSonatypeStagingRepository
   ```

**Publishing Checklist:**

- ✅ All tests passing
- ✅ Checkstyle passes
- ✅ PMD analysis clean
- ✅ SpotBugs finds no issues
- ✅ Version updated
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ LICENSE file present
- ✅ Source JAR generated
- ✅ Javadoc JAR generated
- ✅ Artifacts signed with GPG
- ✅ POM metadata complete

**GitHub Secrets:**

Add these secrets to your repository:

- `MAVEN_USERNAME`: Sonatype username
- `MAVEN_PASSWORD`: Sonatype password
- `GPG_PRIVATE_KEY`: Your GPG private key (exported as ASCII)
- `GPG_PASSPHRASE`: GPG key passphrase

**Alternative: GitHub Packages**

For simpler setup, publish to GitHub Packages:

```xml
<distributionManagement>
    <repository>
        <id>github</id>
        <url>https://maven.pkg.github.com/your-org/your-library</url>
    </repository>
</distributionManagement>
```

Users can then add to their pom.xml:
```xml
<repositories>
    <repository>
        <id>github</id>
        <url>https://maven.pkg.github.com/your-org/*</url>
    </repository>
</repositories>
```

<!-- JAVA:END -->


<!-- ELIXIR:START -->
# Elixir Project Rules

## Elixir Configuration

**CRITICAL**: Use Elixir 1.16+ with OTP 26+.

- **Version**: Elixir 1.16+
- **OTP**: 26+
- **Formatter**: Built-in `mix format`
- **Linter**: Credo
- **Type Checker**: Dialyzer

### mix.exs Requirements

```elixir
defmodule YourProject.MixProject do
  use Mix.Project

  def project do
    [
      app: :your_project,
      version: "1.0.0",
      elixir: "~> 1.16",
      start_permanent: Mix.env() == :prod,
      deps: deps(),
      
      # Documentation
      name: "Your Project",
      source_url: "https://github.com/your-org/your-project",
      docs: [
        main: "readme",
        extras: ["README.md", "CHANGELOG.md"]
      ],
      
      # Testing
      test_coverage: [tool: ExCoveralls],
      preferred_cli_env: [
        coveralls: :test,
        "coveralls.detail": :test,
        "coveralls.post": :test,
        "coveralls.html": :test
      ],
      
      # Dialyzer
      dialyzer: [
        plt_add_apps: [:mix, :ex_unit],
        plt_file: {:no_warn, "priv/plts/dialyzer.plt"},
        flags: [:error_handling, :underspecs]
      ]
    ]
  end

  def application do
    [
      extra_applications: [:logger],
      mod: {YourProject.Application, []}
    ]
  end

  defp deps do
    [
      # Development & Testing
      {:credo, "~> 1.7", only: [:dev, :test], runtime: false},
      {:dialyxir, "~> 1.4", only: [:dev, :test], runtime: false},
      {:excoveralls, "~> 0.18", only: :test},
      {:ex_doc, "~> 0.31", only: :dev, runtime: false}
    ]
  end
end
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
mix format

# 2. Lint (MUST pass with no warnings)
mix credo --strict

# 3. Type check with Dialyzer
mix dialyzer

# 4. Run all tests (MUST pass 100%)
mix test

# 5. Check coverage (MUST meet threshold)
mix coveralls
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Formatting

- Use built-in `mix format`
- Configuration in `.formatter.exs`
- Format before committing: `mix format`

Example `.formatter.exs`:
```elixir
[
  inputs: ["{mix,.formatter}.exs", "{config,lib,test}/**/*.{ex,exs}"],
  line_length: 100
]
```

### Linting

- Use Credo for code analysis
- Configuration in `.credo.exs`
- Must pass strict mode: `mix credo --strict`

Example `.credo.exs`:
```elixir
%{
  configs: [
    %{
      name: "default",
      files: %{
        included: ["lib/", "test/"],
        excluded: [~r"/_build/", ~r"/deps/"]
      },
      strict: true,
      color: true,
      checks: %{
        enabled: [
          {Credo.Check.Readability.ModuleDoc, []},
          {Credo.Check.Design.AliasUsage, priority: :low}
        ]
      }
    }
  ]
}
```

### Testing

- **Framework**: ExUnit (built-in)
- **Location**: `test/` directory
- **Coverage**: ExCoveralls
- **Coverage Threshold**: 95%+

Example test structure:
```elixir
defmodule YourProject.MyModuleTest do
  use ExUnit.Case, async: true
  
  doctest YourProject.MyModule

  describe "function_name/1" do
    test "handles valid input" do
      assert YourProject.MyModule.function_name("input") == {:ok, "result"}
    end

    test "returns error for invalid input" do
      assert YourProject.MyModule.function_name("") == {:error, :invalid_input}
    end
  end
end
```

### Type Specifications

- Use `@spec` for all public functions
- Use `@type` for custom types
- Run Dialyzer regularly

Example:
```elixir
defmodule YourProject.MyModule do
  @moduledoc """
  Documentation for MyModule.
  """

  @type result :: {:ok, String.t()} | {:error, atom()}

  @spec process(String.t()) :: result()
  def process(input) when is_binary(input) and input != "" do
    {:ok, String.upcase(input)}
  end

  def process(_), do: {:error, :invalid_input}
end
```

## Documentation

- Use `@moduledoc` for module documentation
- Use `@doc` for function documentation
- Include examples with doctests
- Generate docs with `mix docs`

Example:
```elixir
defmodule YourProject.MyModule do
  @moduledoc """
  Provides functionality for processing data.

  ## Examples

      iex> YourProject.MyModule.process("hello")
      {:ok, "HELLO"}
  """

  @doc """
  Processes the input string.

  Returns `{:ok, result}` on success or `{:error, reason}` on failure.

  ## Examples

      iex> YourProject.MyModule.process("test")
      {:ok, "TEST"}

      iex> YourProject.MyModule.process("")
      {:error, :invalid_input}
  """
  @spec process(String.t()) :: {:ok, String.t()} | {:error, atom()}
  def process(input) when is_binary(input) and input != "" do
    {:ok, String.upcase(input)}
  end

  def process(_), do: {:error, :invalid_input}
end
```

## Project Structure

```
project/
├── mix.exs             # Project configuration
├── .formatter.exs      # Formatter configuration
├── .credo.exs          # Credo configuration
├── README.md           # Project overview (allowed in root)
├── CHANGELOG.md        # Version history (allowed in root)
├── LICENSE             # Project license (allowed in root)
├── lib/
│   ├── your_project.ex       # Main module
│   └── your_project/
│       ├── application.ex    # OTP application
│       └── ...
├── test/
│   ├── test_helper.exs      # Test configuration
│   └── your_project/
│       └── ...
├── config/
│   ├── config.exs           # General config
│   ├── dev.exs              # Development config
│   ├── test.exs             # Test config
│   └── prod.exs             # Production config
├── priv/                    # Private assets
└── docs/                    # Project documentation
```

## Error Handling

- Use tagged tuples: `{:ok, value}` and `{:error, reason}`
- Use `with` for multiple operations
- Create custom error modules when needed

Example:
```elixir
defmodule YourProject.Errors do
  defmodule ValidationError do
    defexception [:message, :field]
  end
end

defmodule YourProject.MyModule do
  alias YourProject.Errors.ValidationError

  def validate(data) do
    with {:ok, cleaned} <- clean_data(data),
         {:ok, validated} <- check_format(cleaned) do
      {:ok, validated}
    else
      {:error, :empty} -> 
        raise ValidationError, message: "Data cannot be empty", field: :data
      
      {:error, reason} -> 
        {:error, reason}
    end
  end
end
```

## OTP Best Practices

- Use Supervisors for fault tolerance
- Implement GenServers for stateful processes
- Use Task for concurrent operations

Example Supervisor:
```elixir
defmodule YourProject.Application do
  use Application

  @impl true
  def start(_type, _args) do
    children = [
      {YourProject.MyWorker, []},
      {Task.Supervisor, name: YourProject.TaskSupervisor}
    ]

    opts = [strategy: :one_for_one, name: YourProject.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`elixir-test.yml`):
   - Test on ubuntu-latest
   - Test on Elixir 1.16, 1.17
   - Test on OTP 26, 27
   - Upload coverage reports

2. **Linting** (`elixir-lint.yml`):
   - Format check: `mix format --check-formatted`
   - Credo: `mix credo --strict`
   - Dialyzer: `mix dialyzer`

## Package Publication

### Publishing to Hex.pm

**Prerequisites:**
1. Create account at https://hex.pm
2. Generate API key: `mix hex.user auth`
3. Add `HEX_API_KEY` to GitHub repository secrets

**mix.exs Configuration:**

```elixir
def project do
  [
    app: :your_package,
    version: "1.0.0",
    elixir: "~> 1.16",
    description: "A short description of your package",
    package: package(),
    docs: docs()
  ]
end

defp package do
  [
    name: :your_package,
    files: ~w(lib .formatter.exs mix.exs README.md LICENSE CHANGELOG.md),
    licenses: ["MIT"],
    links: %{
      "GitHub" => "https://github.com/your-org/your-package",
      "Changelog" => "https://github.com/your-org/your-package/blob/main/CHANGELOG.md"
    },
    maintainers: ["Your Name"]
  ]
end

defp docs do
  [
    main: "readme",
    extras: ["README.md", "CHANGELOG.md"],
    source_url: "https://github.com/your-org/your-package"
  ]
end
```

**Publishing Workflow:**

1. Update version in mix.exs
2. Update CHANGELOG.md
3. Run quality checks:
   ```bash
   mix format
   mix credo --strict
   mix dialyzer
   mix test
   mix coveralls
   ```

4. Build docs: `mix docs`
5. Build package: `mix hex.build`
6. Create git tag: `git tag v1.0.0 && git push --tags`
7. GitHub Actions automatically publishes to Hex
8. Or manual publish: `mix hex.publish`

**Publishing Checklist:**

- ✅ All tests passing (`mix test`)
- ✅ Coverage meets threshold (`mix coveralls`)
- ✅ Credo passes strict mode (`mix credo --strict`)
- ✅ Dialyzer passes (`mix dialyzer`)
- ✅ Code formatted (`mix format --check-formatted`)
- ✅ Version updated in mix.exs
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ LICENSE file present
- ✅ Documentation builds (`mix docs`)
- ✅ Package metadata complete in mix.exs
- ✅ Verify with `mix hex.build`

**Semantic Versioning:**

Follow [SemVer](https://semver.org/):
- **MAJOR**: Breaking API changes
- **MINOR**: New features (backwards compatible)
- **PATCH**: Bug fixes (backwards compatible)

**Documentation:**

HexDocs automatically generates documentation from your code:
- Published at: `https://hexdocs.pm/your_package`
- Updated automatically when publishing to Hex

<!-- ELIXIR:END -->


<!-- CSHARP:START -->
# C# Project Rules

## C# Configuration

**CRITICAL**: Use .NET 8+ with C# 12+.

- **Version**: .NET 8.0+
- **C# Version**: 12+
- **Target**: net8.0
- **Nullable**: Enabled
- **LangVersion**: latest

### Project File Requirements

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <AnalysisMode>All</AnalysisMode>
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
    
    <!-- Package Metadata -->
    <PackageId>Your.Package.Name</PackageId>
    <Version>1.0.0</Version>
    <Authors>Your Name</Authors>
    <Company>Your Company</Company>
    <Description>A short description of your package</Description>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageProjectUrl>https://github.com/your-org/your-project</PackageProjectUrl>
    <RepositoryUrl>https://github.com/your-org/your-project</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageTags>your;tags</PackageTags>
    
    <!-- Documentation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.NetAnalyzers" Version="8.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
    </PackageReference>
  </ItemGroup>
</Project>
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
dotnet format

# 2. Build (MUST pass with no warnings)
dotnet build --no-incremental

# 3. Run all tests (MUST pass 100%)
dotnet test

# 4. Check coverage (MUST meet threshold)
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Code Style

Use `.editorconfig` for consistent code style:

```ini
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 4
insert_final_newline = true
trim_trailing_whitespace = true

[*.{cs,csx,vb,vbx}]
indent_size = 4

# C# Code Style Rules
[*.cs]
# Organize usings
dotnet_sort_system_directives_first = true
dotnet_separate_import_directive_groups = false

# this. preferences
dotnet_style_qualification_for_field = false:warning
dotnet_style_qualification_for_property = false:warning
dotnet_style_qualification_for_method = false:warning
dotnet_style_qualification_for_event = false:warning

# Language keywords vs BCL types preferences
dotnet_style_predefined_type_for_locals_parameters_members = true:warning
dotnet_style_predefined_type_for_member_access = true:warning

# Modifier preferences
dotnet_style_require_accessibility_modifiers = always:warning
csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:warning

# Expression preferences
csharp_style_var_for_built_in_types = true:warning
csharp_style_var_when_type_is_apparent = true:warning
csharp_style_var_elsewhere = true:warning

# Pattern matching
csharp_style_pattern_matching_over_is_with_cast_check = true:warning
csharp_style_pattern_matching_over_as_with_null_check = true:warning

# Null-checking preferences
csharp_style_throw_expression = true:warning
csharp_style_conditional_delegate_call = true:warning

# Code block preferences
csharp_prefer_braces = true:warning
csharp_prefer_simple_using_statement = true:warning

# Naming conventions
dotnet_naming_rule.interface_should_be_begins_with_i.severity = warning
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

dotnet_naming_rule.types_should_be_pascal_case.severity = warning
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = warning
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# Symbol specifications
dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected

# Naming styles
dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix = 
dotnet_naming_style.begins_with_i.word_separator = 
dotnet_naming_style.begins_with_i.capitalization = pascal_case

dotnet_naming_style.pascal_case.required_prefix = 
dotnet_naming_style.pascal_case.required_suffix = 
dotnet_naming_style.pascal_case.word_separator = 
dotnet_naming_style.pascal_case.capitalization = pascal_case
```

### Testing

- **Framework**: xUnit (recommended) or NUnit
- **Location**: Separate test project
- **Coverage**: Coverlet
- **Coverage Threshold**: 95%+

Example test structure:
```csharp
using Xunit;

namespace YourProject.Tests;

public class MyClassTests
{
    [Fact]
    public void Process_ValidInput_ReturnsExpectedResult()
    {
        // Arrange
        var sut = new MyClass();
        var input = "test";

        // Act
        var result = sut.Process(input);

        // Assert
        Assert.Equal("TEST", result);
    }

    [Theory]
    [InlineData("")]
    [InlineData(null)]
    public void Process_InvalidInput_ThrowsArgumentException(string input)
    {
        // Arrange
        var sut = new MyClass();

        // Act & Assert
        Assert.Throws<ArgumentException>(() => sut.Process(input));
    }
}
```

### Documentation

- Use XML documentation comments
- Document all public APIs
- Include `<summary>`, `<param>`, `<returns>`, `<exception>`

Example:
```csharp
namespace YourProject;

/// <summary>
/// Provides functionality for processing data.
/// </summary>
public class MyClass
{
    /// <summary>
    /// Processes the input string and converts it to uppercase.
    /// </summary>
    /// <param name="input">The input string to process.</param>
    /// <returns>The processed string in uppercase.</returns>
    /// <exception cref="ArgumentException">Thrown when input is null or empty.</exception>
    /// <example>
    /// <code>
    /// var processor = new MyClass();
    /// var result = processor.Process("hello");
    /// // result is "HELLO"
    /// </code>
    /// </example>
    public string Process(string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            throw new ArgumentException("Input cannot be null or empty.", nameof(input));
        }

        return input.ToUpperInvariant();
    }
}
```

## Project Structure

```
project/
├── src/
│   └── YourProject/
│       ├── YourProject.csproj
│       ├── Class1.cs
│       └── ...
├── tests/
│   └── YourProject.Tests/
│       ├── YourProject.Tests.csproj
│       ├── Class1Tests.cs
│       └── ...
├── docs/                    # Project documentation
├── .editorconfig            # Code style configuration
├── Directory.Build.props    # Shared MSBuild properties
├── Directory.Packages.props # Central package management
├── YourProject.sln          # Solution file
├── README.md                # Project overview (allowed in root)
├── CHANGELOG.md             # Version history (allowed in root)
└── LICENSE                  # Project license (allowed in root)
```

## Nullable Reference Types

- Enable nullable reference types
- Use `?` for nullable types
- Use null-forgiving operator `!` sparingly

Example:
```csharp
public class UserService
{
    private readonly ILogger<UserService> _logger;

    public UserService(ILogger<UserService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public User? FindUser(string? username)
    {
        if (string.IsNullOrEmpty(username))
        {
            return null;
        }

        // Implementation
        return new User { Username = username };
    }

    public User GetUser(string username)
    {
        var user = FindUser(username);
        return user ?? throw new InvalidOperationException("User not found");
    }
}
```

## Async/Await Best Practices

- Use `async`/`await` for I/O operations
- Don't block on async code
- Use `ConfigureAwait(false)` in libraries
- Return `Task` or `ValueTask`

Example:
```csharp
public class DataService
{
    private readonly HttpClient _httpClient;

    public async Task<string> FetchDataAsync(string url, CancellationToken cancellationToken = default)
    {
        var response = await _httpClient.GetAsync(url, cancellationToken).ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
        
        return await response.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
    }
}
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`dotnet-test.yml`):
   - Test on ubuntu-latest, windows-latest, macos-latest
   - Test on .NET 8.0
   - Upload coverage reports

2. **Linting** (`dotnet-lint.yml`):
   - Format check: `dotnet format --verify-no-changes`
   - Build: `dotnet build --no-incremental`
   - Analyzers enabled

## Package Publication

### Publishing to NuGet

**Prerequisites:**
1. Create account at https://www.nuget.org
2. Generate API key from account settings
3. Add `NUGET_API_KEY` to GitHub repository secrets

**Publishing Workflow:**

1. Update version in .csproj
2. Update CHANGELOG.md
3. Run quality checks:
   ```bash
   dotnet format --verify-no-changes
   dotnet build --configuration Release
   dotnet test --configuration Release
   ```

4. Pack: `dotnet pack --configuration Release`
5. Create git tag: `git tag v1.0.0 && git push --tags`
6. GitHub Actions automatically publishes to NuGet
7. Or manual publish: `dotnet nuget push bin/Release/*.nupkg --api-key $NUGET_API_KEY --source https://api.nuget.org/v3/index.json`

**Publishing Checklist:**

- ✅ All tests passing
- ✅ Code formatted (`dotnet format`)
- ✅ No build warnings
- ✅ Version updated in .csproj
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ LICENSE file present
- ✅ XML documentation generated
- ✅ Package metadata complete
- ✅ Verify with `dotnet pack`

**Semantic Versioning:**

Use `<Version>` in .csproj with SemVer:
- **MAJOR**: Breaking API changes
- **MINOR**: New features (backwards compatible)
- **PATCH**: Bug fixes (backwards compatible)

<!-- CSHARP:END -->


<!-- PHP:START -->
# PHP Project Rules

## PHP Configuration

**CRITICAL**: Use PHP 8.2+ with strict types enabled.

- **Version**: PHP 8.2+
- **Strict Types**: Enabled
- **Type Hints**: Required for all functions
- **Error Reporting**: E_ALL | E_STRICT

### composer.json Requirements

```json
{
  "name": "your-vendor/your-package",
  "description": "A short description of your package",
  "type": "library",
  "license": "MIT",
  "authors": [
    {
      "name": "Your Name",
      "email": "your.email@example.com"
    }
  ],
  "require": {
    "php": "^8.2"
  },
  "require-dev": {
    "phpunit/phpunit": "^11.0",
    "phpstan/phpstan": "^1.10",
    "squizlabs/php_codesniffer": "^3.8",
    "friendsofphp/php-cs-fixer": "^3.48"
  },
  "autoload": {
    "psr-4": {
      "YourVendor\\YourPackage\\": "src/"
    }
  },
  "autoload-dev": {
    "psr-4": {
      "YourVendor\\YourPackage\\Tests\\": "tests/"
    }
  },
  "scripts": {
    "test": "phpunit",
    "cs-fix": "php-cs-fixer fix",
    "cs-check": "php-cs-fixer fix --dry-run --diff",
    "stan": "phpstan analyse",
    "phpcs": "phpcs src tests"
  },
  "minimum-stability": "stable",
  "prefer-stable": true
}
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
composer cs-fix

# 2. Static analysis (MUST pass with no errors)
composer stan

# 3. Code style check
composer phpcs

# 4. Run all tests (MUST pass 100%)
composer test

# 5. Check coverage (MUST meet threshold)
./vendor/bin/phpunit --coverage-text
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Code Style

Use PHP-CS-Fixer with PSR-12 standard. Configuration in `.php-cs-fixer.php`:

```php
<?php

declare(strict_types=1);

$finder = PhpCsFixer\Finder::create()
    ->in(__DIR__ . '/src')
    ->in(__DIR__ . '/tests');

return (new PhpCsFixer\Config())
    ->setRules([
        '@PSR12' => true,
        '@PHP82Migration' => true,
        'strict_param' => true,
        'array_syntax' => ['syntax' => 'short'],
        'declare_strict_types' => true,
        'native_function_invocation' => ['include' => ['@all']],
        'no_unused_imports' => true,
        'ordered_imports' => ['sort_algorithm' => 'alpha'],
        'phpdoc_align' => true,
        'phpdoc_order' => true,
        'trailing_comma_in_multiline' => ['elements' => ['arrays']],
    ])
    ->setFinder($finder);
```

### Static Analysis

Use PHPStan at maximum level. Configuration in `phpstan.neon`:

```neon
parameters:
    level: max
    paths:
        - src
        - tests
    excludePaths:
        - tests/Fixtures/*
    checkMissingIterableValueType: true
    checkGenericClassInNonGenericObjectType: true
    reportUnmatchedIgnoredErrors: true
```

### Testing

- **Framework**: PHPUnit 11+
- **Location**: `tests/` directory
- **Coverage**: XDebug or PCOV
- **Coverage Threshold**: 95%+

Configuration in `phpunit.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
         failOnRisky="true"
         failOnWarning="true"
         cacheDirectory=".phpunit.cache">
    <testsuites>
        <testsuite name="Unit">
            <directory>tests/Unit</directory>
        </testsuite>
        <testsuite name="Integration">
            <directory>tests/Integration</directory>
        </testsuite>
    </testsuites>
    <source>
        <include>
            <directory>src</directory>
        </include>
    </source>
    <coverage>
        <report>
            <html outputDirectory="coverage"/>
            <text outputFile="php://stdout"/>
        </report>
    </coverage>
</phpunit>
```

Example test:

```php
<?php

declare(strict_types=1);

namespace YourVendor\YourPackage\Tests;

use PHPUnit\Framework\TestCase;
use YourVendor\YourPackage\MyClass;

final class MyClassTest extends TestCase
{
    public function testProcessValidInput(): void
    {
        $myClass = new MyClass();
        $result = $myClass->process('hello');
        
        $this->assertSame('HELLO', $result);
    }

    public function testProcessEmptyInputThrowsException(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('Input cannot be empty');
        
        $myClass = new MyClass();
        $myClass->process('');
    }
}
```

### Type Declarations

- Use strict types in all files
- Type hint all parameters and return types
- Use union types and nullable types appropriately

Example:

```php
<?php

declare(strict_types=1);

namespace YourVendor\YourPackage;

use InvalidArgumentException;

final class DataProcessor
{
    /**
     * Process the input data and return the result.
     *
     * @param string $input The input to process
     * @return string The processed output
     * @throws InvalidArgumentException If input is empty
     */
    public function process(string $input): string
    {
        if ($input === '') {
            throw new InvalidArgumentException('Input cannot be empty');
        }

        return strtoupper($input);
    }

    /**
     * Find a value in the data.
     *
     * @param array<string, mixed> $data
     * @param string $key
     * @return mixed|null
     */
    public function findValue(array $data, string $key): mixed
    {
        return $data[$key] ?? null;
    }

    /**
     * Process multiple items.
     *
     * @param list<string> $items
     * @return list<string>
     */
    public function processMany(array $items): array
    {
        return array_map(
            fn (string $item): string => $this->process($item),
            $items
        );
    }
}
```

## Documentation

- Use PHPDoc blocks for all public methods
- Include `@param`, `@return`, `@throws` tags
- Use generics annotations for arrays

Example:

```php
<?php

declare(strict_types=1);

namespace YourVendor\YourPackage;

/**
 * Service for managing user data.
 *
 * This class provides methods for creating, updating, and retrieving user information.
 */
final class UserService
{
    /**
     * Find a user by ID.
     *
     * @param positive-int $userId The user ID
     * @return array{id: int, name: string, email: string}|null User data or null if not found
     */
    public function findById(int $userId): ?array
    {
        // Implementation
    }

    /**
     * Get all users.
     *
     * @return list<array{id: int, name: string, email: string}>
     */
    public function getAll(): array
    {
        // Implementation
    }
}
```

## Project Structure

```
project/
├── composer.json           # Composer configuration
├── phpunit.xml             # PHPUnit configuration
├── phpstan.neon            # PHPStan configuration
├── .php-cs-fixer.php       # PHP-CS-Fixer configuration
├── README.md               # Project overview (allowed in root)
├── CHANGELOG.md            # Version history (allowed in root)
├── LICENSE                 # Project license (allowed in root)
├── src/
│   └── YourClass.php
├── tests/
│   ├── Unit/
│   └── Integration/
└── docs/                   # Project documentation
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`php-test.yml`):
   - Test on ubuntu-latest, windows-latest
   - Test on PHP 8.2, 8.3
   - Upload coverage reports

2. **Linting** (`php-lint.yml`):
   - PHPStan: `composer stan`
   - PHP-CS-Fixer: `composer cs-check`
   - PHPCS: `composer phpcs`

## Package Publication

### Publishing to Packagist

**Prerequisites:**
1. Create account at https://packagist.org
2. Submit your package (automatic sync with GitHub)
3. Configure webhook in GitHub for auto-updates

**Publishing Workflow:**

1. Update version in composer.json (optional, uses git tags)
2. Update CHANGELOG.md
3. Run quality checks:
   ```bash
   composer cs-fix
   composer stan
   composer test
   ```

4. Create git tag: `git tag v1.0.0 && git push --tags`
5. Packagist automatically updates from GitHub
6. Package available at: `https://packagist.org/packages/your-vendor/your-package`

**Publishing Checklist:**

- ✅ All tests passing
- ✅ PHPStan at max level passes
- ✅ Code style conforms to PSR-12
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ LICENSE file present
- ✅ composer.json metadata complete
- ✅ GitHub repository public
- ✅ Webhook configured on Packagist

**Semantic Versioning:**

Packagist uses git tags for versions:
- Tag format: `v1.0.0`
- Follows [SemVer](https://semver.org/)
- Composer constraints: `^1.0`, `~1.0`, `1.0.*`

<!-- PHP:END -->


<!-- SWIFT:START -->
# Swift Project Rules

## Swift Configuration

**CRITICAL**: Use Swift 5.10+ with strict concurrency checking.

- **Version**: Swift 5.10+
- **Platform**: iOS 17+, macOS 14+
- **Concurrency**: Enabled
- **Warnings as Errors**: true

### Package.swift Requirements

```swift
// swift-tools-version: 5.10
import PackageDescription

let package = Package(
    name: "YourPackage",
    platforms: [
        .iOS(.v17),
        .macOS(.v14),
        .watchOS(.v10),
        .tvOS(.v17)
    ],
    products: [
        .library(
            name: "YourPackage",
            targets: ["YourPackage"]
        ),
    ],
    dependencies: [],
    targets: [
        .target(
            name: "YourPackage",
            dependencies: [],
            swiftSettings: [
                .enableUpcomingFeature("StrictConcurrency"),
                .enableUpcomingFeature("BareSlashRegexLiterals"),
                .enableExperimentalFeature("StrictConcurrency=complete")
            ]
        ),
        .testTarget(
            name: "YourPackageTests",
            dependencies: ["YourPackage"]
        ),
    ]
)
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
swift-format --in-place --recursive Sources Tests

# 2. Lint
swiftlint

# 3. Build (MUST pass with no warnings)
swift build -Xswiftc -warnings-as-errors

# 4. Run all tests (MUST pass 100%)
swift test

# 5. Generate documentation
swift package generate-documentation
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Code Style

Use SwiftLint for code style. Configuration in `.swiftlint.yml`:

```yaml
disabled_rules:
  - trailing_whitespace

opt_in_rules:
  - empty_count
  - explicit_init
  - first_where
  - closure_spacing
  - overridden_super_call
  - redundant_nil_coalescing
  - private_outlet
  - nimble_operator
  - attributes
  - operator_usage_whitespace
  - closure_end_indentation
  - literal_expression_end_indentation

included:
  - Sources
  - Tests

excluded:
  - .build
  - .swiftpm
  - DerivedData

line_length:
  warning: 120
  error: 140
  ignores_comments: true

type_body_length:
  warning: 300
  error: 400

file_length:
  warning: 500
  error: 800

function_body_length:
  warning: 40
  error: 60

identifier_name:
  min_length:
    warning: 2
  max_length:
    warning: 50
    error: 60

custom_rules:
  no_hardcoded_strings:
    name: "No Hardcoded Strings"
    regex: '(print|NSLog)\("'
    message: "Use localized strings instead of hardcoded strings"
    severity: warning
```

### Testing

- **Framework**: XCTest (built-in)
- **Location**: `Tests/` directory
- **Async**: Use async/await in tests
- **Coverage**: xcodebuild or swift-testing

Example test:

```swift
import XCTest
@testable import YourPackage

final class YourPackageTests: XCTestCase {
    func testProcessValidInput() async throws {
        let processor = DataProcessor()
        let result = try await processor.process("hello")
        
        XCTAssertEqual(result, "HELLO")
    }
    
    func testProcessEmptyInputThrowsError() async {
        let processor = DataProcessor()
        
        await XCTAssertThrowsError(try await processor.process("")) { error in
            XCTAssertEqual(error as? ProcessorError, .emptyInput)
        }
    }
    
    func testPerformanceExample() {
        let processor = DataProcessor()
        
        measure {
            _ = try? processor.processSync("test")
        }
    }
}

// Helper extension for async testing
extension XCTestCase {
    func XCTAssertThrowsError<T>(
        _ expression: @autoclosure () async throws -> T,
        _ errorHandler: (Error) -> Void
    ) async {
        do {
            _ = try await expression()
            XCTFail("Should have thrown an error")
        } catch {
            errorHandler(error)
        }
    }
}
```

### Documentation

- Use Swift DocC for documentation
- Document all public APIs with `///`
- Include examples and parameters

Example:

```swift
/// A processor that transforms input data.
///
/// Use this class to process strings and perform transformations.
/// The processor supports both synchronous and asynchronous operations.
///
/// ## Usage
///
/// ```swift
/// let processor = DataProcessor()
/// let result = try await processor.process("hello")
/// print(result) // Prints: HELLO
/// ```
public final class DataProcessor: Sendable {
    
    /// Creates a new data processor.
    public init() {}
    
    /// Processes the input string asynchronously.
    ///
    /// This method transforms the input by converting it to uppercase.
    ///
    /// - Parameter input: The string to process. Must not be empty.
    /// - Returns: The processed string in uppercase.
    /// - Throws: `ProcessorError.emptyInput` if the input is empty.
    ///
    /// ## Example
    ///
    /// ```swift
    /// let processor = DataProcessor()
    /// let result = try await processor.process("hello")
    /// // result is "HELLO"
    /// ```
    public func process(_ input: String) async throws -> String {
        guard !input.isEmpty else {
            throw ProcessorError.emptyInput
        }
        
        return input.uppercased()
    }
}

/// Errors that can occur during processing.
public enum ProcessorError: Error, Sendable {
    /// The input string was empty.
    case emptyInput
    /// An invalid format was encountered.
    case invalidFormat(String)
}
```

### Concurrency

- Use `async`/`await` for asynchronous code
- Mark types as `Sendable` when thread-safe
- Use actors for state synchronization
- Enable strict concurrency checking

Example:

```swift
/// An actor that manages user data safely across concurrent access.
public actor UserManager {
    private var users: [String: User] = [:]
    
    /// Adds or updates a user.
    public func setUser(_ user: User, for id: String) {
        users[id] = user
    }
    
    /// Retrieves a user by ID.
    public func getUser(for id: String) -> User? {
        users[id]
    }
}

/// A thread-safe data structure.
public struct User: Sendable {
    public let id: String
    public let name: String
    public let email: String
    
    public init(id: String, name: String, email: String) {
        self.id = id
        self.name = name
        self.email = email
    }
}

/// Example of using actors with async/await
public final class UserService: Sendable {
    private let manager = UserManager()
    
    public init() {}
    
    public func fetchUser(id: String) async -> User? {
        // Actor-isolated access
        await manager.getUser(for: id)
    }
    
    public func saveUser(_ user: User) async {
        await manager.setUser(user, for: user.id)
    }
}
```

## Project Structure

```
project/
├── Package.swift           # Swift Package Manager manifest
├── .swiftlint.yml          # SwiftLint configuration
├── .swift-format           # SwiftFormat configuration
├── README.md               # Project overview (allowed in root)
├── CHANGELOG.md            # Version history (allowed in root)
├── LICENSE                 # Project license (allowed in root)
├── Sources/
│   └── YourPackage/
│       ├── YourPackage.swift
│       └── ...
├── Tests/
│   └── YourPackageTests/
│       └── YourPackageTests.swift
└── docs/                   # Project documentation
```

## Error Handling

- Use Swift's native error handling
- Create custom error types conforming to `Error`
- Use `Result` type for functions that don't throw
- Implement `LocalizedError` for user-facing errors

Example:

```swift
public enum NetworkError: Error {
    case invalidURL
    case noData
    case decodingFailed(Error)
    case httpError(statusCode: Int)
}

extension NetworkError: LocalizedError {
    public var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "The URL provided was invalid."
        case .noData:
            return "No data was received from the server."
        case .decodingFailed(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        case .httpError(let statusCode):
            return "HTTP error occurred with status code: \(statusCode)"
        }
    }
}
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`swift-test.yml`):
   - Test on macos-latest
   - Test on Swift 5.10
   - Run on iOS, macOS platforms

2. **Linting** (`swift-lint.yml`):
   - SwiftLint: `swiftlint`
   - SwiftFormat: `swift-format lint --recursive .`
   - Build with warnings as errors

## Package Publication

### Publishing Swift Packages

Swift packages are published via Git tags and automatically indexed by Swift Package Index.

**Prerequisites:**
1. Public Git repository
2. Valid Package.swift
3. Semantic version tags

**Publishing Workflow:**

1. Update version documentation
2. Update CHANGELOG.md
3. Run quality checks:
   ```bash
   swift-format --in-place --recursive Sources Tests
   swiftlint
   swift build -Xswiftc -warnings-as-errors
   swift test
   ```

4. Create git tag: `git tag 1.0.0 && git push --tags`
5. Add to Swift Package Index: https://swiftpackageindex.com/add-a-package
6. Package available via Swift Package Manager

**Publishing Checklist:**

- ✅ All tests passing
- ✅ SwiftLint passes
- ✅ Code formatted with swift-format
- ✅ Build succeeds with warnings as errors
- ✅ CHANGELOG.md updated
- ✅ README.md with installation instructions
- ✅ LICENSE file present
- ✅ Documentation generated with DocC
- ✅ Package.swift metadata complete
- ✅ Semantic version tag created

**Package.swift Metadata:**

```swift
let package = Package(
    name: "YourPackage",
    platforms: [.iOS(.v17), .macOS(.v14)],
    products: [
        .library(name: "YourPackage", targets: ["YourPackage"]),
    ],
    targets: [
        .target(name: "YourPackage"),
        .testTarget(name: "YourPackageTests", dependencies: ["YourPackage"]),
    ]
)
```

**Usage by Consumers:**

```swift
dependencies: [
    .package(url: "https://github.com/your-org/your-package.git", from: "1.0.0")
]
```

<!-- SWIFT:END -->


<!-- KOTLIN:START -->
# Kotlin Project Rules

## Kotlin Configuration

**CRITICAL**: Use Kotlin 2.0+ with strict null safety.

- **Version**: Kotlin 2.0+
- **JVM Target**: 17+
- **Language Features**: All enabled
- **Compiler**: K2 compiler
- **Null Safety**: Strict

### build.gradle.kts Requirements

```kotlin
plugins {
    kotlin("jvm") version "2.0.0"
    id("org.jetbrains.dokka") version "1.9.20"
    id("io.gitlab.arturbosch.detekt") version "1.23.5"
    id("org.jlleitschuh.gradle.ktlint") version "12.1.0"
    `maven-publish`
    signing
}

group = "io.github.your-username"
version = "1.0.0"

repositories {
    mavenCentral()
}

dependencies {
    implementation(kotlin("stdlib"))
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0")
    
    testImplementation(kotlin("test"))
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.8.0")
    testImplementation("io.mockk:mockk:1.13.9")
}

kotlin {
    jvmToolchain(17)
    
    compilerOptions {
        freeCompilerArgs.add("-Xjsr305=strict")
        freeCompilerArgs.add("-Xcontext-receivers")
        allWarningsAsErrors.set(true)
    }
}

tasks.test {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        jvmTarget = "17"
        freeCompilerArgs = listOf(
            "-Xjsr305=strict",
            "-Xcontext-receivers"
        )
        allWarningsAsErrors = true
    }
}

detekt {
    config.setFrom(files("$rootDir/detekt.yml"))
    buildUponDefaultConfig = true
    allRules = false
}

ktlint {
    version.set("1.1.0")
    android.set(false)
    ignoreFailures.set(false)
}
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
./gradlew ktlintFormat

# 2. Lint
./gradlew detekt

# 3. Build (MUST pass with no warnings)
./gradlew build

# 4. Run all tests (MUST pass 100%)
./gradlew test

# 5. Check coverage (MUST meet threshold)
./gradlew koverHtmlReport
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Code Style

Use ktlint with `.editorconfig`:

```ini
root = true

[*]
charset = utf-8
end_of_line = lf
indent_size = 4
indent_style = space
insert_final_newline = true
max_line_length = 120
tab_width = 4

[*.{kt,kts}]
ij_kotlin_allow_trailing_comma = true
ij_kotlin_allow_trailing_comma_on_call_site = true

# Imports
ij_kotlin_imports_layout = *,java.**,javax.**,kotlin.**,^

# Wrapping
ij_kotlin_line_break_after_multiline_when_entry = true
ij_kotlin_wrap_expression_body_functions = 1
ij_kotlin_wrap_first_method_in_call_chain = false

# Spacing
ij_kotlin_space_after_type_colon = true
ij_kotlin_space_before_type_colon = false
```

### Static Analysis

Use Detekt. Configuration in `detekt.yml`:

```yaml
build:
  maxIssues: 0
  weights:
    complexity: 2
    LongParameterList: 1
    style: 1
    comments: 1

complexity:
  active: true
  ComplexMethod:
    threshold: 15
  LongMethod:
    threshold: 60
  LongParameterList:
    functionThreshold: 6
  TooManyFunctions:
    thresholdInFiles: 15

naming:
  active: true
  FunctionNaming:
    active: true
  ClassNaming:
    active: true
  VariableNaming:
    active: true

style:
  active: true
  MagicNumber:
    active: true
  ReturnCount:
    max: 3

coroutines:
  active: true
  GlobalCoroutineUsage:
    active: true
  SuspendFunWithFlowReturnType:
    active: true
```

### Testing

- **Framework**: JUnit 5 (Jupiter)
- **Mocking**: MockK
- **Coroutines**: kotlinx-coroutines-test
- **Coverage**: Kover
- **Coverage Threshold**: 95%+

Example test:

```kotlin
import io.mockk.*
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import kotlin.test.assertEquals

class DataProcessorTest {
    
    @Test
    fun `process valid input returns uppercase`() {
        val processor = DataProcessor()
        val result = processor.process("hello")
        
        assertEquals("HELLO", result)
    }
    
    @Test
    fun `process empty input throws exception`() {
        val processor = DataProcessor()
        
        assertThrows<IllegalArgumentException> {
            processor.process("")
        }
    }
    
    @Test
    fun `processAsync works correctly`() = runTest {
        val processor = DataProcessor()
        val result = processor.processAsync("test")
        
        assertEquals("TEST", result)
    }
    
    @Test
    fun `test with mocking`() {
        val repository = mockk<UserRepository>()
        every { repository.findById(1) } returns User(1, "John")
        
        val service = UserService(repository)
        val user = service.getUser(1)
        
        assertEquals("John", user?.name)
        verify { repository.findById(1) }
    }
}
```

### Null Safety

- Use non-null types by default
- Use `?` for nullable types
- Use safe calls `?.` and Elvis operator `?:`
- Avoid `!!` operator (use only when absolutely necessary)

Example:

```kotlin
data class User(
    val id: Int,
    val name: String,
    val email: String?,
    val phone: String? = null
)

class UserService(private val repository: UserRepository) {
    
    fun findUser(id: Int): User? {
        return repository.findById(id)
    }
    
    fun getUserName(id: Int): String {
        val user = findUser(id) ?: throw UserNotFoundException(id)
        return user.name
    }
    
    fun getUserEmail(id: Int): String {
        val user = findUser(id) ?: return "unknown@example.com"
        return user.email ?: "no-email@example.com"
    }
    
    fun processUsers(ids: List<Int>): List<String> {
        return ids.mapNotNull { id ->
            findUser(id)?.name
        }
    }
}
```

### Coroutines

- Use structured concurrency
- Prefer `suspend` functions over callbacks
- Use `Flow` for reactive streams
- Handle cancellation properly

Example:

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

class DataService(private val api: ApiClient) {
    
    suspend fun fetchData(id: Int): Result<Data> = withContext(Dispatchers.IO) {
        try {
            val data = api.getData(id)
            Result.success(data)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    fun observeData(id: Int): Flow<Data> = flow {
        while (currentCoroutineContext().isActive) {
            val data = api.getData(id)
            emit(data)
            delay(1000)
        }
    }.flowOn(Dispatchers.IO)
    
    suspend fun fetchMultiple(ids: List<Int>): List<Data> = coroutineScope {
        ids.map { id ->
            async { fetchData(id).getOrNull() }
        }.awaitAll().filterNotNull()
    }
}
```

### Data Classes & Sealed Classes

- Use `data class` for value objects
- Use `sealed class`/`sealed interface` for restricted hierarchies
- Use `value class` for single-property wrappers

Example:

```kotlin
// Data class for DTOs
data class User(
    val id: Int,
    val name: String,
    val email: String
)

// Sealed hierarchy for results
sealed interface Result<out T> {
    data class Success<T>(val data: T) : Result<T>
    data class Error(val exception: Exception) : Result<Nothing>
    data object Loading : Result<Nothing>
}

// Value class for type safety
@JvmInline
value class UserId(val value: Int)

@JvmInline
value class Email(val value: String) {
    init {
        require(value.contains("@")) { "Invalid email format" }
    }
}
```

### Documentation

- Use KDoc for documentation
- Document all public APIs
- Include examples with `@sample`

Example:

```kotlin
/**
 * A processor that transforms input data.
 *
 * This class provides methods for processing strings synchronously and asynchronously.
 * All processing is done in a thread-safe manner.
 *
 * @property config Configuration for the processor
 * @constructor Creates a processor with the given configuration
 */
class DataProcessor(private val config: ProcessorConfig = ProcessorConfig()) {
    
    /**
     * Processes the input string synchronously.
     *
     * @param input The string to process. Must not be empty.
     * @return The processed string in uppercase.
     * @throws IllegalArgumentException if [input] is empty.
     * @sample samples.DataProcessorSamples.processExample
     */
    fun process(input: String): String {
        require(input.isNotEmpty()) { "Input cannot be empty" }
        return input.uppercase()
    }
    
    /**
     * Processes the input string asynchronously.
     *
     * This is a suspending function that can be called from a coroutine.
     *
     * @param input The string to process.
     * @return The processed string in uppercase.
     */
    suspend fun processAsync(input: String): String = withContext(Dispatchers.Default) {
        process(input)
    }
}

// Sample code for documentation
object samples {
    object DataProcessorSamples {
        fun processExample() {
            val processor = DataProcessor()
            val result = processor.process("hello")
            println(result) // Prints: HELLO
        }
    }
}
```

## Project Structure

```
project/
├── build.gradle.kts        # Gradle build configuration
├── settings.gradle.kts     # Gradle settings
├── detekt.yml              # Detekt configuration
├── .editorconfig           # EditorConfig for ktlint
├── README.md               # Project overview (allowed in root)
├── CHANGELOG.md            # Version history (allowed in root)
├── LICENSE                 # Project license (allowed in root)
├── src/
│   ├── main/
│   │   └── kotlin/
│   │       └── com/yourorg/yourproject/
│   │           └── YourClass.kt
│   └── test/
│       └── kotlin/
│           └── com/yourorg/yourproject/
│               └── YourClassTest.kt
└── docs/                   # Project documentation
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`kotlin-test.yml`):
   - Test on ubuntu-latest, windows-latest
   - Test on Java 17, 21
   - Upload coverage reports

2. **Linting** (`kotlin-lint.yml`):
   - Detekt: `./gradlew detekt`
   - ktlint: `./gradlew ktlintCheck`
   - Build with warnings as errors

## Package Publication

### Publishing to Maven Central

Same process as Java (see JAVA.md), but with Kotlin-specific configuration.

**Publishing Checklist:**

- ✅ All tests passing
- ✅ Detekt passes
- ✅ ktlint passes
- ✅ Build succeeds with warnings as errors
- ✅ Version updated in build.gradle.kts
- ✅ CHANGELOG.md updated
- ✅ README.md up to date
- ✅ LICENSE file present
- ✅ Dokka documentation generated
- ✅ Artifacts signed with GPG

**Dokka Documentation:**

```kotlin
tasks.dokkaHtml.configure {
    outputDirectory.set(buildDir.resolve("dokka"))
}
```

<!-- KOTLIN:END -->


<!-- CPP:START -->
# C/C++ Project Rules

## C/C++ Configuration

**CRITICAL**: Use C++20 or C++23 with modern CMake.

- **C++ Standard**: C++20 or C++23
- **CMake**: 3.25+
- **Compiler**: GCC 11+, Clang 15+, or MSVC 19.30+
- **Build System**: CMake (recommended) or Meson
- **Package Manager**: Conan or vcpkg

### CMakeLists.txt Requirements

```cmake
cmake_minimum_required(VERSION 3.25)
project(YourProject VERSION 1.0.0 LANGUAGES CXX)

# C++ Standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Compiler warnings
if(MSVC)
    add_compile_options(/W4 /WX)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)
endif()

# Export compile commands for tooling
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Project options
option(BUILD_TESTING "Build tests" ON)
option(BUILD_DOCS "Build documentation" ON)
option(ENABLE_SANITIZERS "Enable sanitizers" ON)

# Dependencies (using FetchContent or find_package)
include(FetchContent)

FetchContent_Declare(
    googletest
    GIT_REPOSITORY https://github.com/google/googletest.git
    GIT_TAG v1.14.0
)
FetchContent_MakeAvailable(googletest)

# Library
add_library(${PROJECT_NAME}
    src/your_module.cpp
    src/your_module.hpp
)

target_include_directories(${PROJECT_NAME}
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Enable sanitizers in debug
if(ENABLE_SANITIZERS AND CMAKE_BUILD_TYPE MATCHES Debug)
    target_compile_options(${PROJECT_NAME} PRIVATE
        -fsanitize=address
        -fsanitize=undefined
        -fno-omit-frame-pointer
    )
    target_link_options(${PROJECT_NAME} PRIVATE
        -fsanitize=address
        -fsanitize=undefined
    )
endif()

# Tests
if(BUILD_TESTING)
    enable_testing()
    add_subdirectory(tests)
endif()

# Installation
install(TARGETS ${PROJECT_NAME}
    EXPORT ${PROJECT_NAME}Targets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    INCLUDES DESTINATION include
)
```

## Code Quality Standards

### Mandatory Quality Checks

**CRITICAL**: After implementing ANY feature, you MUST run these commands in order:

```bash
# 1. Format code
clang-format -i src/**/*.{cpp,hpp} tests/**/*.{cpp,hpp}

# 2. Static analysis
clang-tidy src/**/*.cpp -- -std=c++20

# 3. Build (MUST pass with no warnings)
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# 4. Run all tests (MUST pass 100%)
ctest --test-dir build --output-on-failure

# 5. Check with sanitizers
cmake -B build -DENABLE_SANITIZERS=ON
cmake --build build
ctest --test-dir build

# 6. Check coverage
cmake -B build -DCMAKE_BUILD_TYPE=Coverage
cmake --build build
ctest --test-dir build
gcov build/CMakeFiles/YourProject.dir/src/*.gcno
```

**If ANY of these fail, you MUST fix the issues before committing.**

### Code Style

Use `.clang-format` for consistent formatting:

```yaml
---
Language: Cpp
BasedOnStyle: Google
IndentWidth: 4
ColumnLimit: 100
UseTab: Never
PointerAlignment: Left
ReferenceAlignment: Left
DerivePointerAlignment: false

# Includes
SortIncludes: CaseInsensitive
IncludeBlocks: Regroup
IncludeCategories:
  - Regex: '^<.*\.h>'
    Priority: 1
  - Regex: '^<.*>'
    Priority: 2
  - Regex: '.*'
    Priority: 3

# Braces
BreakBeforeBraces: Attach
AllowShortFunctionsOnASingleLine: Inline
AllowShortIfStatementsOnASingleLine: Never

# Spacing
SpaceAfterCStyleCast: false
SpaceAfterTemplateKeyword: true
SpaceBeforeParens: ControlStatements

# Modern C++
Standard: c++20
```

### Static Analysis

Use `.clang-tidy` for code analysis:

```yaml
---
Checks: >
  *,
  -abseil-*,
  -altera-*,
  -android-*,
  -fuchsia-*,
  -google-*,
  -llvm-*,
  -llvmlibc-*,
  -zircon-*,
  -readability-identifier-length,
  -modernize-use-trailing-return-type

CheckOptions:
  - key: readability-identifier-naming.NamespaceCase
    value: lower_case
  - key: readability-identifier-naming.ClassCase
    value: CamelCase
  - key: readability-identifier-naming.StructCase
    value: CamelCase
  - key: readability-identifier-naming.FunctionCase
    value: camelCase
  - key: readability-identifier-naming.VariableCase
    value: lower_case
  - key: readability-identifier-naming.ConstantCase
    value: UPPER_CASE
  - key: readability-identifier-naming.MemberCase
    value: lower_case_
  - key: readability-identifier-naming.PrivateMemberSuffix
    value: '_'

WarningsAsErrors: '*'
```

### Testing

- **Framework**: Google Test (recommended) or Catch2
- **Location**: `tests/` directory
- **Coverage**: gcov/lcov or llvm-cov
- **Coverage Threshold**: 95%+

Example test with Google Test:

```cpp
#include <gtest/gtest.h>
#include "your_module.hpp"

namespace your_namespace::tests {

class DataProcessorTest : public ::testing::Test {
protected:
    void SetUp() override {
        processor = std::make_unique<DataProcessor>();
    }

    void TearDown() override {
        processor.reset();
    }

    std::unique_ptr<DataProcessor> processor;
};

TEST_F(DataProcessorTest, ProcessValidInput) {
    const std::string input = "hello";
    const auto result = processor->process(input);
    
    EXPECT_EQ(result, "HELLO");
}

TEST_F(DataProcessorTest, ProcessEmptyInputThrows) {
    EXPECT_THROW(
        processor->process(""),
        std::invalid_argument
    );
}

TEST_F(DataProcessorTest, ProcessLargeInput) {
    const std::string input(1000, 'a');
    const auto result = processor->process(input);
    
    ASSERT_EQ(result.size(), 1000);
    EXPECT_TRUE(std::all_of(result.begin(), result.end(), 
        [](char c) { return std::isupper(c); }));
}

} // namespace your_namespace::tests
```

### Modern C++ Best Practices

- Use RAII for resource management
- Prefer `std::unique_ptr` and `std::shared_ptr` over raw pointers
- Use `const` and `constexpr` liberally
- Prefer `std::string_view` for read-only strings
- Use range-based for loops
- Use `auto` for type deduction when clear
- Avoid manual memory management

Example modern C++ code:

```cpp
#pragma once

#include <memory>
#include <string>
#include <string_view>
#include <vector>
#include <optional>
#include <expected>

namespace your_namespace {

/// @brief Processes data with various transformations
class DataProcessor {
public:
    DataProcessor() = default;
    ~DataProcessor() = default;
    
    // Delete copy constructor and assignment
    DataProcessor(const DataProcessor&) = delete;
    DataProcessor& operator=(const DataProcessor&) = delete;
    
    // Default move constructor and assignment
    DataProcessor(DataProcessor&&) noexcept = default;
    DataProcessor& operator=(DataProcessor&&) noexcept = default;
    
    /// @brief Process input string to uppercase
    /// @param input The input string to process
    /// @return Processed string or error
    /// @throws std::invalid_argument if input is empty
    [[nodiscard]] std::string process(std::string_view input) const;
    
    /// @brief Find value in data
    /// @param data The data to search
    /// @param key The key to find
    /// @return Optional value if found
    [[nodiscard]] std::optional<std::string> findValue(
        const std::vector<std::pair<std::string, std::string>>& data,
        std::string_view key
    ) const;
    
    /// @brief Process multiple items
    /// @param items Items to process
    /// @return Processed items
    [[nodiscard]] std::vector<std::string> processMany(
        const std::vector<std::string>& items
    ) const;

private:
    mutable std::mutex mutex_;
};

} // namespace your_namespace
```

Implementation:

```cpp
#include "your_module.hpp"
#include <algorithm>
#include <stdexcept>
#include <cctype>

namespace your_namespace {

std::string DataProcessor::process(std::string_view input) const {
    if (input.empty()) {
        throw std::invalid_argument("Input cannot be empty");
    }
    
    std::string result;
    result.reserve(input.size());
    
    std::transform(input.begin(), input.end(), 
                   std::back_inserter(result),
                   [](unsigned char c) { return std::toupper(c); });
    
    return result;
}

std::optional<std::string> DataProcessor::findValue(
    const std::vector<std::pair<std::string, std::string>>& data,
    std::string_view key
) const {
    auto it = std::find_if(data.begin(), data.end(),
        [key](const auto& pair) { return pair.first == key; });
    
    if (it != data.end()) {
        return it->second;
    }
    
    return std::nullopt;
}

std::vector<std::string> DataProcessor::processMany(
    const std::vector<std::string>& items
) const {
    std::vector<std::string> results;
    results.reserve(items.size());
    
    std::transform(items.begin(), items.end(),
                   std::back_inserter(results),
                   [this](const auto& item) { return process(item); });
    
    return results;
}

} // namespace your_namespace
```

## Documentation

Use Doxygen for API documentation:

```cpp
/**
 * @file your_module.hpp
 * @brief Data processing utilities
 * @author Your Name
 * @date 2024-10-23
 */

/**
 * @class DataProcessor
 * @brief Processes various data formats
 * 
 * This class provides thread-safe data processing capabilities.
 * All methods are const-correct and exception-safe.
 * 
 * @example
 * @code{.cpp}
 * DataProcessor processor;
 * auto result = processor.process("hello");
 * assert(result == "HELLO");
 * @endcode
 */
```

### Doxyfile Configuration:

```
PROJECT_NAME = "Your Project"
PROJECT_NUMBER = 1.0.0
OUTPUT_DIRECTORY = docs
GENERATE_HTML = YES
GENERATE_LATEX = NO
EXTRACT_ALL = YES
EXTRACT_PRIVATE = NO
EXTRACT_STATIC = YES
SOURCE_BROWSER = YES
INLINE_SOURCES = YES
RECURSIVE = YES
```

## Project Structure

```
project/
├── CMakeLists.txt          # CMake configuration
├── .clang-format           # Code formatting rules
├── .clang-tidy             # Static analysis rules
├── Doxyfile                # Documentation config
├── conanfile.txt           # Conan dependencies (optional)
├── vcpkg.json              # vcpkg dependencies (optional)
├── README.md               # Project overview
├── CHANGELOG.md            # Version history
├── LICENSE                 # Project license
├── include/
│   └── your_project/
│       └── your_module.hpp # Public headers
├── src/
│   └── your_module.cpp     # Implementation
├── tests/
│   ├── CMakeLists.txt
│   └── test_your_module.cpp
├── benchmarks/             # Performance benchmarks
│   └── benchmark_main.cpp
└── docs/                   # Project documentation
```

## Memory Safety

- Use RAII for all resource management
- Prefer stack allocation over heap
- Use smart pointers for heap allocation
- Never use raw `new`/`delete`
- Use containers instead of manual arrays
- Check all pointer dereferences

Example:

```cpp
// Good: RAII with smart pointers
class FileManager {
public:
    explicit FileManager(std::string_view filename) 
        : file_(std::make_unique<std::ifstream>(filename.data())) {
        if (!file_->is_open()) {
            throw std::runtime_error("Failed to open file");
        }
    }
    
    // RAII - file automatically closed
    ~FileManager() = default;
    
    [[nodiscard]] std::string readLine() {
        std::string line;
        if (std::getline(*file_, line)) {
            return line;
        }
        throw std::runtime_error("Failed to read line");
    }

private:
    std::unique_ptr<std::ifstream> file_;
};

// Bad: Manual memory management
class BadFileManager {
public:
    BadFileManager(const char* filename) {
        file = new std::ifstream(filename);  // ❌ Manual allocation
    }
    
    ~BadFileManager() {
        delete file;  // ❌ Manual deletion (error-prone)
    }

private:
    std::ifstream* file;  // ❌ Raw pointer
};
```

## Error Handling

- Use exceptions for exceptional cases
- Use `std::expected` (C++23) or `std::optional` for expected failures
- Create custom exception classes
- Document all exceptions with `@throws`

Example:

```cpp
#include <stdexcept>
#include <optional>

namespace your_namespace {

class ValidationError : public std::runtime_error {
public:
    explicit ValidationError(std::string_view message, std::string_view field)
        : std::runtime_error(std::string(message))
        , field_(field) {}
    
    [[nodiscard]] const std::string& field() const noexcept { return field_; }

private:
    std::string field_;
};

class DataValidator {
public:
    /// @throws ValidationError if data is invalid
    void validate(std::string_view data) const {
        if (data.empty()) {
            throw ValidationError("Data cannot be empty", "data");
        }
    }
    
    /// @return Optional value if valid, nullopt otherwise
    [[nodiscard]] std::optional<int> tryParse(std::string_view str) const noexcept {
        try {
            return std::stoi(std::string(str));
        } catch (...) {
            return std::nullopt;
        }
    }
};

} // namespace your_namespace
```

## Threading & Concurrency

- Use `std::thread`, `std::jthread` (C++20), or `std::async`
- Use `std::mutex`, `std::shared_mutex` for synchronization
- Prefer `std::atomic` for simple shared state
- Use `std::lock_guard` or `std::scoped_lock`

Example:

```cpp
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <atomic>

class ThreadSafeCounter {
public:
    void increment() {
        std::scoped_lock lock(mutex_);
        ++counter_;
    }
    
    [[nodiscard]] int get() const {
        std::shared_lock lock(mutex_);
        return counter_;
    }

private:
    mutable std::shared_mutex mutex_;
    int counter_{0};
};

// For simple atomics
class AtomicCounter {
public:
    void increment() noexcept {
        counter_.fetch_add(1, std::memory_order_relaxed);
    }
    
    [[nodiscard]] int get() const noexcept {
        return counter_.load(std::memory_order_relaxed);
    }

private:
    std::atomic<int> counter_{0};
};
```

## CI/CD Requirements

Must include GitHub Actions workflows for:

1. **Testing** (`cpp-test.yml`):
   - Test on ubuntu-latest, windows-latest, macos-latest
   - Test with GCC, Clang, MSVC
   - Upload coverage reports

2. **Linting** (`cpp-lint.yml`):
   - clang-format check
   - clang-tidy analysis
   - cppcheck static analysis

## Package Publication

### Publishing C/C++ Libraries

**Options:**
1. **Conan Center**: Public Conan repository
2. **vcpkg**: Microsoft's package manager
3. **GitHub Releases**: Binary releases
4. **Header-only**: Single-file distribution

### Conan Publication

**conanfile.py:**

```python
from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout

class YourProjectConan(ConanFile):
    name = "your-project"
    version = "1.0.0"
    license = "MIT"
    author = "Your Name your.email@example.com"
    url = "https://github.com/your-org/your-project"
    description = "Short description"
    topics = ("cpp", "library")
    settings = "os", "compiler", "build_type", "arch"
    
    options = {
        "shared": [True, False],
        "fPIC": [True, False]
    }
    default_options = {
        "shared": False,
        "fPIC": True
    }
    
    exports_sources = "CMakeLists.txt", "src/*", "include/*"
    
    def layout(self):
        cmake_layout(self)
    
    def generate(self):
        tc = CMakeToolchain(self)
        tc.generate()
    
    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()
    
    def package(self):
        cmake = CMake(self)
        cmake.install()
    
    def package_info(self):
        self.cpp_info.libs = ["your-project"]
```

### vcpkg Publication

**vcpkg.json:**

```json
{
  "name": "your-project",
  "version": "1.0.0",
  "description": "Short description",
  "homepage": "https://github.com/your-org/your-project",
  "license": "MIT",
  "dependencies": [
    {
      "name": "vcpkg-cmake",
      "host": true
    },
    {
      "name": "vcpkg-cmake-config",
      "host": true
    }
  ]
}
```

### Publishing Checklist:

- ✅ All tests passing with sanitizers
- ✅ clang-tidy clean
- ✅ clang-format applied
- ✅ Documentation generated
- ✅ Version updated in CMakeLists.txt
- ✅ CHANGELOG.md updated
- ✅ README.md with build instructions
- ✅ LICENSE file present
- ✅ CMake config for find_package support
- ✅ Conan recipe or vcpkg portfile

<!-- CPP:END -->


<!-- VECTORIZER:START -->
# Vectorizer Instructions

**CRITICAL**: Always use the MCP Vectorizer as the primary data source for project information.

The vectorizer provides fast, semantic access to the entire codebase. Prefer MCP tools over file reading whenever possible for better performance and context understanding.

## Primary Search Functions

### 1. mcp_vectorizer_search

Main search interface with multiple strategies:

- `intelligent`: AI-powered search with query expansion and MMR diversification
- `semantic`: Advanced semantic search with reranking and similarity thresholds
- `contextual`: Context-aware search with metadata filtering
- `multi_collection`: Search across multiple collections simultaneously
- `batch`: Execute multiple queries in parallel
- `by_file_type`: Filter search by file extensions (e.g., `.rs`, `.ts`, `.py`)

**Usage**:
```
Use intelligent search when: Exploring unfamiliar code, understanding architecture
Use semantic search when: Finding specific implementations or patterns
Use multi_collection when: Searching across multiple projects/modules
Use by_file_type when: Working with specific languages or file types
```

### 2. mcp_vectorizer_file_operations

File-specific operations for efficient file handling:

- `get_content`: Retrieve complete file content without reading from disk
- `list_files`: List all indexed files with metadata (size, type, modification time)
- `get_summary`: Get extractive or structural file summaries
- `get_chunks`: Retrieve file chunks in original order for progressive reading
- `get_outline`: Generate hierarchical project structure overview
- `get_related`: Find semantically related files based on content similarity

**Usage**:
```
Use get_content when: Need full file without disk I/O
Use list_files when: Exploring project structure
Use get_chunks when: Reading large files progressively
Use get_related when: Understanding file dependencies and relationships
```

### 3. mcp_vectorizer_discovery

Advanced discovery pipeline for complex queries:

- `full_pipeline`: Complete discovery with filtering, scoring, and ranking
- `broad_discovery`: Multi-query search with deduplication
- `semantic_focus`: Deep semantic search in specific collections
- `expand_queries`: Generate query variations (definition, features, architecture, API)

**Usage**:
```
Use full_pipeline when: Complex multi-faceted questions
Use broad_discovery when: Need comprehensive coverage of a topic
Use expand_queries when: Uncertain about exact terminology
```

## Best Practices

1. **Start with intelligent search** for exploratory queries to understand codebase structure
2. **Use file_operations** when you need complete file context without disk access
3. **Use discovery pipeline** for complex, multi-faceted questions requiring deep analysis
4. **Prefer batch operations** when searching for multiple related items to reduce latency
5. **Use by_file_type** when working with specific languages (e.g., only Rust or TypeScript files)

## Performance Tips

- **Batch queries** instead of sequential searches for better performance
- **Use specific collections** when you know the target area to reduce search space
- **Set similarity thresholds** to filter out irrelevant results (typically 0.6-0.8)
- **Cache results** for repeated queries within the same session

## Common Patterns

### Pattern 1: Understanding a Feature
```
1. Use intelligent search to find feature implementation
2. Use get_related to find connected files
3. Use get_outline to understand feature structure
4. Use get_content to read specific implementations
```

### Pattern 2: Debugging an Issue
```
1. Use semantic search with error message or symptom
2. Use by_file_type to focus on relevant language files
3. Use get_chunks to progressively read large files
4. Use get_related to find potentially affected files
```

### Pattern 3: Adding a New Feature
```
1. Use expand_queries to find similar existing features
2. Use full_pipeline for comprehensive discovery
3. Use get_outline to understand where to add code
4. Use get_related to find integration points
```

<!-- VECTORIZER:END -->


<!-- CONTEXT7:START -->
# Context7 Instructions

**CRITICAL**: Use MCP Context7 to access up-to-date library documentation before adding dependencies.

Context7 provides real-time access to documentation for thousands of libraries and frameworks. Always check Context7 before adding new dependencies to ensure you're using the latest stable versions and following best practices.

## Core Functions

### 1. resolve-library-id

Resolve a package name to a Context7-compatible library ID:

```
Input: Library name (e.g., "tokio", "react", "fastapi")
Output: Context7 library ID (e.g., "/tokio-rs/tokio", "/facebook/react")
```

**MUST** use this function before `get-library-docs` unless the user provides an explicit library ID.

### 2. get-library-docs

Fetch documentation for a library:

```
Input: Context7 library ID, optional topic, token limit
Output: Relevant documentation, examples, API reference
```

Options:
- `topic`: Focus on specific area (e.g., "routing", "hooks", "async")
- `tokens`: Control documentation size (default: 5000)

## Mandatory Usage

### Before Adding Dependencies

**CRITICAL**: Check Context7 for every new dependency.

#### Rust Example
```
Adding tokio:
1. resolve-library-id("tokio") → "/tokio-rs/tokio"
2. get-library-docs("/tokio-rs/tokio") → Latest version, features, examples
3. Check for breaking changes in latest version
4. Add to Cargo.toml with correct version and features
```

#### TypeScript Example
```
Adding express:
1. resolve-library-id("express") → "/expressjs/express"
2. get-library-docs("/expressjs/express") → Latest version, middleware patterns
3. Review TypeScript type definitions availability
4. Add to package.json with latest stable version
```

#### Python Example
```
Adding fastapi:
1. resolve-library-id("fastapi") → "/tiangolo/fastapi"
2. get-library-docs("/tiangolo/fastapi", topic="async") → Async patterns
3. Check Python version requirements
4. Add to pyproject.toml or requirements.txt
```

## Best Practices

### 1. Version Verification

Always verify the latest stable version:

```
1. Use resolve-library-id to find the library
2. Use get-library-docs to see current version
3. Check for security advisories
4. Review changelog for breaking changes
5. Document version choice in code/commits
```

### 2. Topic-Focused Queries

Use the topic parameter for specific information:

```
Examples:
- get-library-docs("/tokio-rs/tokio", topic="channels")
- get-library-docs("/facebook/react", topic="hooks")
- get-library-docs("/psf/requests", topic="authentication")
```

### 3. Migration Guides

When updating major versions:

```
1. Get docs for current version
2. Get docs for target version
3. Look for migration guide in documentation
4. Review breaking changes
5. Plan migration strategy
```

### 4. Best Practices Discovery

Learn idiomatic usage patterns:

```
1. Get library docs with relevant topic
2. Review code examples
3. Check for recommended patterns
4. Follow security best practices
5. Implement according to documentation
```

## Integration with Development Workflow

### Adding New Dependency

```
1. Identify need for library
2. Use resolve-library-id to find correct library
3. Use get-library-docs to review:
   - Latest stable version
   - Features and capabilities
   - Usage examples
   - Security considerations
4. Add dependency with correct version
5. Document why this library was chosen
6. Update CHANGELOG.md
```

### Updating Existing Dependency

```
1. Use get-library-docs for current version
2. Use get-library-docs for latest version
3. Review changelog between versions
4. Check for breaking changes
5. Update code if needed
6. Update dependency version
7. Test thoroughly
```

### Troubleshooting

```
1. Use get-library-docs with specific topic
2. Search for error message or issue
3. Review examples for correct usage
4. Check for known issues or workarounds
5. Verify you're following best practices
```

## Common Patterns

### Pattern 1: Dependency Selection

```
Problem: Need HTTP client library

1. resolve-library-id("requests") for Python
   OR resolve-library-id("reqwest") for Rust
   OR resolve-library-id("axios") for TypeScript

2. get-library-docs for each candidate

3. Compare features, performance, maintenance

4. Choose best fit for requirements

5. Document decision
```

### Pattern 2: Feature Discovery

```
Need: Async file operations in Rust

1. resolve-library-id("tokio") → "/tokio-rs/tokio"
2. get-library-docs("/tokio-rs/tokio", topic="file I/O")
3. Review async file operation examples
4. Implement using documented patterns
```

### Pattern 3: Security Verification

```
Before adding crypto library:

1. resolve-library-id("ring") for Rust
2. get-library-docs("/briansmith/ring")
3. Check security audit status
4. Review recommended algorithms
5. Verify actively maintained
6. Add with appropriate features
```

## Library ID Format

Context7 library IDs follow patterns:

- GitHub: `/org/repo` or `/org/repo/version`
- Examples:
  - `/tokio-rs/tokio`
  - `/vercel/next.js`
  - `/psf/requests`
  - `/vercel/next.js/v14.0.0` (specific version)

## Error Handling

If library not found:

1. Verify correct library name
2. Try alternative names or repos
3. Check if library is on supported platforms
4. Consider using official documentation as fallback

<!-- CONTEXT7:END -->
